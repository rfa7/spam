SCRIPT  /usr/local/share/vim/vim74/ftplugin/python.vim
Sourced 1 time
Total time:   0.000421
 Self time:   0.000421

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	python
                            " Maintainer:	Johannes Zellner <johannes@zellner.org>
                            " Last Change:	2014 Feb 09
                            " Last Change By Johannes: Wed, 21 Apr 2004 13:13:08 CEST
                            
    1              0.000011 if exists("b:did_ftplugin") | finish | endif
    1              0.000006 let b:did_ftplugin = 1
    1              0.000010 let s:keepcpo= &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000008 setlocal cinkeys-=0#
    1              0.000006 setlocal indentkeys-=0#
    1              0.000006 setlocal include=^\\s*\\(from\\\|import\\)
    1              0.000006 setlocal includeexpr=substitute(v:fname,'\\.','/','g')
    1              0.000006 setlocal suffixesadd=.py
    1              0.000006 setlocal comments=b:#,fb:-
    1              0.000006 setlocal commentstring=#\ %s
                            
    1              0.000005 setlocal omnifunc=pythoncomplete#Complete
                            
    1              0.000009 set wildignore+=*.pyc
                            
    1              0.000035 nnoremap <silent> <buffer> ]] :call <SID>Python_jump('/^\(class\\|def\)')<cr>
    1              0.000019 nnoremap <silent> <buffer> [[ :call <SID>Python_jump('?^\(class\\|def\)')<cr>
    1              0.000019 nnoremap <silent> <buffer> ]m :call <SID>Python_jump('/^\s*\(class\\|def\)')<cr>
    1              0.000019 nnoremap <silent> <buffer> [m :call <SID>Python_jump('?^\s*\(class\\|def\)')<cr>
                            
    1              0.000007 if !exists('*<SID>Python_jump')
    1              0.000006   fun! <SID>Python_jump(motion) range
                                  let cnt = v:count1
                                  let save = @/    " save last search pattern
                                  mark '
                                  while cnt > 0
                            	  silent! exe a:motion
                            	  let cnt = cnt - 1
                                  endwhile
                                  call histdel('/', -1)
                                  let @/ = save    " restore last search pattern
                              endfun
    1              0.000003 endif
                            
    1              0.000009 if has("browsefilter") && !exists("b:browsefilter")
    1              0.000009     let b:browsefilter = "Python Files (*.py)\t*.py\n" .
                            		       \ "All Files (*.*)\t*.*\n"
    1              0.000002 endif
                            
                            " As suggested by PEP8.
    1              0.000018 setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8
                            
                            " First time: try finding "pydoc".
    1              0.000005 if !exists('g:pydoc_executable')
    1              0.000026     if executable('pydoc')
    1              0.000006         let g:pydoc_executable = 1
    1              0.000003     else
                                    let g:pydoc_executable = 0
                                endif
    1              0.000002 endif
                            " If "pydoc" was found use it for keywordprg.
    1              0.000003 if g:pydoc_executable
    1              0.000007     setlocal keywordprg=pydoc
    1              0.000003 endif
                            
    1              0.000012 let &cpo = s:keepcpo
    1              0.000007 unlet s:keepcpo

SCRIPT  /usr/local/share/vim/vim74/indent/python.vim
Sourced 1 time
Total time:   0.000542
 Self time:   0.000542

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Python
                            " Maintainer:		Bram Moolenaar <Bram@vim.org>
                            " Original Author:	David Bustos <bustos@caltech.edu>
                            " Last Change:		2013 Jul 9
                            
                            " Only load this indent file when no other was loaded.
    1              0.000007 if exists("b:did_indent")
                              finish
                            endif
    1              0.000005 let b:did_indent = 1
                            
                            " Some preliminary settings
    1              0.000019 setlocal nolisp		" Make sure lisp indenting doesn't supersede us
    1              0.000010 setlocal autoindent	" indentexpr isn't much help otherwise
                            
    1              0.000007 setlocal indentexpr=GetPythonIndent(v:lnum)
    1              0.000006 setlocal indentkeys+=<:>,=elif,=except
                            
                            " Only define the function once.
    1              0.000006 if exists("*GetPythonIndent")
                              finish
                            endif
    1              0.000061 let s:keepcpo= &cpo
    1              0.000012 set cpo&vim
                            
                            " Come here when loading the script the first time.
                            
    1              0.000006 let s:maxoff = 50	" maximum number of lines to look backwards for ()
                            
    1              0.000004 function GetPythonIndent(lnum)
                            
                              " If this line is explicitly joined: If the previous line was also joined,
                              " line it up with that one, otherwise add two 'shiftwidth'
                              if getline(a:lnum - 1) =~ '\\$'
                                if a:lnum > 1 && getline(a:lnum - 2) =~ '\\$'
                                  return indent(a:lnum - 1)
                                endif
                                return indent(a:lnum - 1) + (exists("g:pyindent_continue") ? eval(g:pyindent_continue) : (shiftwidth() * 2))
                              endif
                            
                              " If the start of the line is in a string don't change the indent.
                              if has('syntax_items')
                            	\ && synIDattr(synID(a:lnum, 1, 1), "name") =~ "String$"
                                return -1
                              endif
                            
                              " Search backwards for the previous non-empty line.
                              let plnum = prevnonblank(v:lnum - 1)
                            
                              if plnum == 0
                                " This is the first non-empty line, use zero indent.
                                return 0
                              endif
                            
                              " If the previous line is inside parenthesis, use the indent of the starting
                              " line.
                              " Trick: use the non-existing "dummy" variable to break out of the loop when
                              " going too far back.
                              call cursor(plnum, 1)
                              let parlnum = searchpair('(\|{\|\[', '', ')\|}\|\]', 'nbW',
                            	  \ "line('.') < " . (plnum - s:maxoff) . " ? dummy :"
                            	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                            	  \ . " =~ '\\(Comment\\|Todo\\|String\\)$'")
                              if parlnum > 0
                                let plindent = indent(parlnum)
                                let plnumstart = parlnum
                              else
                                let plindent = indent(plnum)
                                let plnumstart = plnum
                              endif
                            
                            
                              " When inside parenthesis: If at the first line below the parenthesis add
                              " two 'shiftwidth', otherwise same as previous line.
                              " i = (a
                              "       + b
                              "       + c)
                              call cursor(a:lnum, 1)
                              let p = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
                            	  \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
                            	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                            	  \ . " =~ '\\(Comment\\|Todo\\|String\\)$'")
                              if p > 0
                                if p == plnum
                                  " When the start is inside parenthesis, only indent one 'shiftwidth'.
                                  let pp = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
                            	  \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
                            	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                            	  \ . " =~ '\\(Comment\\|Todo\\|String\\)$'")
                                  if pp > 0
                            	return indent(plnum) + (exists("g:pyindent_nested_paren") ? eval(g:pyindent_nested_paren) : shiftwidth())
                                  endif
                                  return indent(plnum) + (exists("g:pyindent_open_paren") ? eval(g:pyindent_open_paren) : (shiftwidth() * 2))
                                endif
                                if plnumstart == p
                                  return indent(plnum)
                                endif
                                return plindent
                              endif
                            
                            
                              " Get the line and remove a trailing comment.
                              " Use syntax highlighting attributes when possible.
                              let pline = getline(plnum)
                              let pline_len = strlen(pline)
                              if has('syntax_items')
                                " If the last character in the line is a comment, do a binary search for
                                " the start of the comment.  synID() is slow, a linear search would take
                                " too long on a long line.
                                if synIDattr(synID(plnum, pline_len, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                                  let min = 1
                                  let max = pline_len
                                  while min < max
                            	let col = (min + max) / 2
                            	if synIDattr(synID(plnum, col, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                            	  let max = col
                            	else
                            	  let min = col + 1
                            	endif
                                  endwhile
                                  let pline = strpart(pline, 0, min - 1)
                                endif
                              else
                                let col = 0
                                while col < pline_len
                                  if pline[col] == '#'
                            	let pline = strpart(pline, 0, col)
                            	break
                                  endif
                                  let col = col + 1
                                endwhile
                              endif
                            
                              " If the previous line ended with a colon, indent this line
                              if pline =~ ':\s*$'
                                return plindent + shiftwidth()
                              endif
                            
                              " If the previous line was a stop-execution statement...
                              if getline(plnum) =~ '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                                " See if the user has already dedented
                                if indent(a:lnum) > indent(plnum) - shiftwidth()
                                  " If not, recommend one dedent
                                  return indent(plnum) - shiftwidth()
                                endif
                                " Otherwise, trust the user
                                return -1
                              endif
                            
                              " If the current line begins with a keyword that lines up with "try"
                              if getline(a:lnum) =~ '^\s*\(except\|finally\)\>'
                                let lnum = a:lnum - 1
                                while lnum >= 1
                                  if getline(lnum) =~ '^\s*\(try\|except\)\>'
                            	let ind = indent(lnum)
                            	if ind >= indent(a:lnum)
                            	  return -1	" indent is already less than this
                            	endif
                            	return ind	" line up with previous try or except
                                  endif
                                  let lnum = lnum - 1
                                endwhile
                                return -1		" no matching "try"!
                              endif
                            
                              " If the current line begins with a header keyword, dedent
                              if getline(a:lnum) =~ '^\s*\(elif\|else\)\>'
                            
                                " Unless the previous line was a one-liner
                                if getline(plnumstart) =~ '^\s*\(for\|if\|try\)\>'
                                  return plindent
                                endif
                            
                                " Or the user has already dedented
                                if indent(a:lnum) <= plindent - shiftwidth()
                                  return -1
                                endif
                            
                                return plindent - shiftwidth()
                              endif
                            
                              " When after a () construct we probably want to go back to the start line.
                              " a = (b
                              "       + c)
                              " here
                              if parlnum > 0
                                return plindent
                              endif
                            
                              return -1
                            
                            endfunction
                            
    1              0.000014 let &cpo = s:keepcpo
    1              0.000004 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/share/vim/vim74/syntax/python.vim
Sourced 1 time
Total time:   0.002033
 Self time:   0.002033

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2015 Sep 15
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " For version 5.x: Clear all syntax items.
                            " For version 6.x: Quit when a syntax file was already loaded.
    1              0.000005 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    1              0.000014 let s:cpo_save = &cpo
    1              0.000011 set cpo&vim
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/2/reference/lexical_analysis.html#keywords,
                            " https://docs.python.org/3/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3 and 2.
                            " We include Python 3 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3 but they are
                            "   built-ins in 2 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3 and will be highlighted.
                            " - 'print' is a built-in in Python 3 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2)
                            " - async and await were added in Python 3.5 and are soft keywords.
                            "
    1              0.000037 syn keyword pythonStatement	False, None, True
    1              0.000008 syn keyword pythonStatement	as assert break continue del exec global
    1              0.000007 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    1              0.000012 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    1              0.000010 syn keyword pythonConditional	elif else if
    1              0.000010 syn keyword pythonRepeat	for while
    1              0.000008 syn keyword pythonOperator	and in is not or
    1              0.000007 syn keyword pythonException	except finally raise try
    1              0.000009 syn keyword pythonInclude	from import
    1              0.000010 syn keyword pythonAsync		async await
                            
                            " Decorators (new in Python 2.4)
    1              0.000013 syn match   pythonDecorator	"@" display nextgroup=pythonFunction skipwhite
                            " The zero-length non-grouping match before the function name is
                            " extremely important in pythonFunction.  Without it, everything is
                            " interpreted as a function inside the contained environment of
                            " doctests.
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    1              0.000017 syn match   pythonFunction
                                  \ "\%(\%(def\s\|class\s\|@\)\s*\)\@<=\h\%(\w\|\.\)*" contained
                            
    1              0.000021 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    1              0.000008 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    1              0.000037 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    1              0.000051 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    1              0.000031 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    1              0.000019 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    1              0.000011 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    1              0.000011 syn match   pythonEscape	"\\\o\{1,3}" contained
    1              0.000010 syn match   pythonEscape	"\\x\x\{2}" contained
    1              0.000013 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    1              0.000012 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    1              0.000010 syn match   pythonEscape	"\\$"
                            
    1              0.000006 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/2/reference/lexical_analysis.html#numeric-literals
                            " https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
    1              0.000005 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    1              0.000016   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    1              0.000009   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    1              0.000010   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    1              0.000010   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    1              0.000009   syn match   pythonNumber	"\<\d\+[jJ]\>"
    1              0.000009   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    1              0.000013   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    1              0.000013   syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    1              0.000003 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/2/library/constants.html
                            " https://docs.python.org/3/library/constants.html
                            " http://docs.python.org/2/library/functions.html
                            " http://docs.python.org/3/library/functions.html
                            " http://docs.python.org/2/library/functions.html#non-essential-built-in-functions
                            " http://docs.python.org/3/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    1              0.000006 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    1              0.000012   syn keyword pythonBuiltin	False True None
    1              0.000012   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    1              0.000015   syn keyword pythonBuiltin	abs all any bin bool bytearray callable chr
    1              0.000009   syn keyword pythonBuiltin	classmethod compile complex delattr dict dir
    1              0.000009   syn keyword pythonBuiltin	divmod enumerate eval filter float format
    1              0.000008   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    1              0.000008   syn keyword pythonBuiltin	help hex id input int isinstance
    1              0.000008   syn keyword pythonBuiltin	issubclass iter len list locals map max
    1              0.000008   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    1              0.000008   syn keyword pythonBuiltin	print property range repr reversed round set
    1              0.000008   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    1              0.000008   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2 only
    1              0.000008   syn keyword pythonBuiltin	basestring cmp execfile file
    1              0.000013   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    1              0.000007   syn keyword pythonBuiltin	unicode xrange
                              " Python 3 only
    1              0.000007   syn keyword pythonBuiltin	ascii bytes exec
                              " non-essential built-in functions; Python 2 only
    1              0.000008   syn keyword pythonBuiltin	apply buffer coerce intern
    1              0.000002 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/2/library/exceptions.html
                            " http://docs.python.org/3/library/exceptions.html
    1              0.000006 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    1              0.000008   syn keyword pythonExceptions	BaseException Exception
    1              0.000007   syn keyword pythonExceptions	ArithmeticError BufferError
    1              0.000006   syn keyword pythonExceptions	LookupError
                              " builtin base exceptions removed in Python 3
    1              0.000007   syn keyword pythonExceptions	EnvironmentError StandardError
                              " builtin exceptions (actually raised)
    1              0.000007   syn keyword pythonExceptions	AssertionError AttributeError
    1              0.000007   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    1              0.000007   syn keyword pythonExceptions	ImportError IndentationError
    1              0.000007   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    1              0.000007   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    1              0.000007   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    1              0.000008   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    1              0.000007   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    1              0.000007   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    1              0.000006   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    1              0.000007   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    1              0.000006   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin OS exceptions in Python 3
    1              0.000006   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    1              0.000008   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    1              0.000010   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    1              0.000032   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    1              0.000019   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    1              0.000030   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    1              0.000019   syn keyword pythonExceptions	PermissionError ProcessLookupError
    1              0.000019   syn keyword pythonExceptions	RecursionError StopAsyncIteration
    1              0.000012   syn keyword pythonExceptions	TimeoutError
                              " builtin exceptions deprecated/removed in Python 3
    1              0.000024   syn keyword pythonExceptions	IOError VMSError WindowsError
                              " builtin warnings
    1              0.000024   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    1              0.000019   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    1              0.000024   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    1              0.000018   syn keyword pythonExceptions	UserWarning Warning
                              " builtin warnings in Python 3
    1              0.000013   syn keyword pythonExceptions	ResourceWarning
    1              0.000003 endif
                            
    1              0.000006 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    1              0.000006 if !exists("python_no_doctest_highlight")
    1              0.000005   if !exists("python_no_doctest_code_highlight")
    1              0.000020     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,@Spell
    1              0.000023     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    1              0.000003   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    1              0.000003 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    1              0.000022 syn sync match pythonSync grouphere NONE "^\s*\%(def\|class\)\s\+\h\w*\s*("
                            
    1              0.000005 if version >= 508 || !exists("did_python_syn_inits")
    1              0.000003   if version <= 508
                                let did_python_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    1              0.000023     command -nargs=+ HiLink hi def link <args>
    1              0.000002   endif
                            
                              " The default highlight links.  Can be overridden later.
    1              0.000016   HiLink pythonStatement	Statement
    1              0.000015   HiLink pythonConditional	Conditional
    1              0.000010   HiLink pythonRepeat		Repeat
    1              0.000010   HiLink pythonOperator		Operator
    1              0.000010   HiLink pythonException	Exception
    1              0.000010   HiLink pythonInclude		Include
    1              0.000010   HiLink pythonAsync		Statement
    1              0.000010   HiLink pythonDecorator	Define
    1              0.000009   HiLink pythonFunction		Function
    1              0.000010   HiLink pythonComment		Comment
    1              0.000009   HiLink pythonTodo		Todo
    1              0.000009   HiLink pythonString		String
    1              0.000009   HiLink pythonRawString	String
    1              0.000009   HiLink pythonQuotes		String
    1              0.000006   HiLink pythonTripleQuotes	pythonQuotes
    1              0.000013   HiLink pythonEscape		Special
    1              0.000007   if !exists("python_no_number_highlight")
    1              0.000009     HiLink pythonNumber		Number
    1              0.000002   endif
    1              0.000006   if !exists("python_no_builtin_highlight")
    1              0.000011     HiLink pythonBuiltin	Function
    1              0.000003   endif
    1              0.000005   if !exists("python_no_exception_highlight")
    1              0.000011     HiLink pythonExceptions	Structure
    1              0.000003   endif
    1              0.000005   if exists("python_space_error_highlight")
                                HiLink pythonSpaceError	Error
                              endif
    1              0.000005   if !exists("python_no_doctest_highlight")
    1              0.000010     HiLink pythonDoctest	Special
    1              0.000009     HiLink pythonDoctestValue	Define
    1              0.000003   endif
                            
    1              0.000004   delcommand HiLink
    1              0.000003 endif
                            
    1              0.000006 let b:current_syntax = "python"
                            
    1              0.000017 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/flake8.vim
Sourced 1 time
Total time:   0.001682
 Self time:   0.000628

count  total (s)   self (s)
                            "============================================================================
                            "File:        flake8.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Authors:     Sylvain Soliman <Sylvain dot Soliman+git at gmail dot com>
                            "             kstep <me@kstep.me>
                            "
                            "============================================================================
                            
    1              0.000009 if exists('g:loaded_syntastic_python_flake8_checker')
                                finish
                            endif
    1              0.000007 let g:loaded_syntastic_python_flake8_checker = 1
                            
    1              0.000016 let s:save_cpo = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000007 function! SyntaxCheckers_python_flake8_GetHighlightRegex(item)
                                return SyntaxCheckers_python_pyflakes_GetHighlightRegex(a:item)
                            endfunction
                            
    1              0.000004 function! SyntaxCheckers_python_flake8_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat =
                                    \ '%E%f:%l: could not compile,%-Z%p^,' .
                                    \ '%A%f:%l:%c: %t%n %m,' .
                                    \ '%A%f:%l: %t%n %m,' .
                                    \ '%-G%.%#'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env })
                            
                                for e in loclist
                                    " E*** and W*** are pep8 errors
                                    " F*** are PyFlakes codes
                                    " C*** are McCabe complexity messages
                                    " N*** are naming conventions from pep8-naming
                            
                                    if has_key(e, 'nr')
                                        let e['text'] .= printf(' [%s%03d]', e['type'], e['nr'])
                                        " E901 are syntax errors
                                        " E902 are I/O errors
                                        if e['type'] ==? 'E' && e['nr'] !~# '\m^9'
                                            let e['subtype'] = 'Style'
                                        endif
                                        call remove(e, 'nr')
                                    endif
                            
                                    if e['type'] =~? '\m^[CNW]'
                                        let e['subtype'] = 'Style'
                                    endif
                            
                                    let e['type'] = e['type'] =~? '\m^[EFC]' ? 'E' : 'W'
                                endfor
                            
                                return loclist
                            endfunction
                            
    1              0.000098 runtime! syntax_checkers/python/pyflakes.vim
                            
    1   0.000351   0.000015 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'flake8'})
                            
    1              0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/pyflakes.vim
Sourced 3 times
Total time:   0.000763
 Self time:   0.000397

count  total (s)   self (s)
                            "============================================================================
                            "File:        pyflakes.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Authors:     Martin Grenfell <martin.grenfell@gmail.com>
                            "             kstep <me@kstep.me>
                            "             Parantapa Bhattacharya <parantapa@gmail.com>
                            "
                            "============================================================================
                            
    3              0.000029 if exists('g:loaded_syntastic_python_pyflakes_checker')
    2              0.000006     finish
                            endif
    1              0.000076 let g:loaded_syntastic_python_pyflakes_checker = 1
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000006 function! SyntaxCheckers_python_pyflakes_GetHighlightRegex(i)
                                if stridx(a:i['text'], 'is assigned to but never used') >= 0
                                    \ || stridx(a:i['text'], 'imported but unused') >= 0
                                    \ || stridx(a:i['text'], 'undefined name') >= 0
                                    \ || stridx(a:i['text'], 'redefinition of') >= 0
                                    \ || stridx(a:i['text'], 'referenced before assignment') >= 0
                                    \ || stridx(a:i['text'], 'duplicate argument') >= 0
                                    \ || stridx(a:i['text'], 'after other statements') >= 0
                                    \ || stridx(a:i['text'], 'shadowed by loop variable') >= 0
                            
                                    " fun with Python's %r: try "..." first, then '...'
                                    let term = matchstr(a:i['text'], '\m^.\{-}"\zs.\{-1,}\ze"')
                                    if term !=# ''
                                        return '\V\<' . escape(term, '\') . '\>'
                                    endif
                            
                                    let term = matchstr(a:i['text'], '\m^.\{-}''\zs.\{-1,}\ze''')
                                    if term !=# ''
                                        return '\V\<' . escape(term, '\') . '\>'
                                    endif
                                endif
                                return ''
                            endfunction
                            
    1              0.000014 function! SyntaxCheckers_python_pyflakes_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat =
                                    \ '%E%f:%l: could not compile,'.
                                    \ '%-Z%p^,'.
                                    \ '%E%f:%l:%c: %m,'.
                                    \ '%E%f:%l: %m,'.
                                    \ '%-G%.%#'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'defaults': {'text': 'Syntax error'} })
                            
                                for e in loclist
                                    let e['vcol'] = 0
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000384   0.000018 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'pyflakes'})
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/frosted.vim
Sourced 1 time
Total time:   0.000532
 Self time:   0.000191

count  total (s)   self (s)
                            "============================================================================
                            "File:        frosted.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000008 if exists('g:loaded_syntastic_python_frosted_checker')
                                finish
                            endif
    1              0.000006 let g:loaded_syntastic_python_frosted_checker = 1
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000006 function! SyntaxCheckers_python_frosted_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args_after': '-vb' })
                            
                                let errorformat =
                                    \ '%f:%l:%c:%m,' .
                                    \ '%E%f:%l: %m,' .
                                    \ '%-Z%p^,' .
                                    \ '%-G%.%#'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'returns': [0, 1] })
                            
                                for e in loclist
                                    let e['col'] += 1
                            
                                    let parts = matchlist(e.text, '\v^([EW]\d+):([^:]*):(.+)')
                                    if len(parts) >= 4
                                        let e['type'] = parts[1][0]
                                        let e['text'] = parts[3] . ' [' . parts[1] . ']'
                                        let e['hl'] = '\V\<' . escape(parts[2], '\') . '\>'
                                    elseif e['text'] =~? '\v^I\d+:'
                                        let e['valid'] = 0
                                    else
                                        let e['vcol'] = 0
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000355   0.000014 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'frosted' })
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/mypy.vim
Sourced 1 time
Total time:   0.000461
 Self time:   0.000134

count  total (s)   self (s)
                            "============================================================================
                            "File:        mypy.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Author:      Russ Hewgill <Russ dot Hewgill at gmail dot com>
                            "
                            "============================================================================
                            
    1              0.000007 if exists('g:loaded_syntastic_python_mypy_checker')
                                finish
                            endif
    1              0.000005 let g:loaded_syntastic_python_mypy_checker = 1
                            
    1              0.000013 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000005 function! SyntaxCheckers_python_mypy_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat = '%f:%l:%m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': { 'type': 'E' },
                                    \ 'returns': [0, 1],
                                    \ 'preprocess': 'mypy' })
                            endfunction
                            
    1   0.000340   0.000013 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'mypy'})
                            
    1              0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/pep257.vim
Sourced 1 time
Total time:   0.000506
 Self time:   0.000170

count  total (s)   self (s)
                            "============================================================================
                            "File:        pep257.vim
                            "Description: Docstring style checking plugin for syntastic.vim
                            "============================================================================
                            
    1              0.000009 if exists('g:loaded_syntastic_python_pep257_checker')
                                finish
                            endif
    1              0.000006 let g:loaded_syntastic_python_pep257_checker = 1
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000005 function! SyntaxCheckers_python_pep257_GetLocList() dict
                                if !exists('s:pep257_new')
                                    let s:pep257_new = syntastic#util#versionIsAtLeast(self.getVersion(), [0, 3])
                                endif
                            
                                let makeprg = self.makeprgBuild({})
                            
                                if s:pep257_new
                                    let errorformat =
                                        \ '%E%f:%l %.%#:,' .
                                        \ '%+C        %m'
                                else
                                    let errorformat =
                                        \ '%E%f:%l:%c%\%.%\%.%\d%\+:%\d%\+: %m,' .
                                        \ '%E%f:%l:%c: %m,' .
                                        \ '%+C    %m'
                                endif
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'subtype': 'Style',
                                    \ 'preprocess': 'killEmpty',
                                    \ 'postprocess': ['compressWhitespace'] })
                            
                                if s:pep257_new == 0
                                    " byte offsets rather than column numbers
                                    for e in loclist
                                        let e['col'] = get(e, 'col', 0) + 1
                                    endfor
                                endif
                            
                                return loclist
                            endfunction
                            
    1   0.000348   0.000012 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'pep257'})
                            
    1              0.000014 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/pep8.vim
Sourced 1 time
Total time:   0.000517
 Self time:   0.000173

count  total (s)   self (s)
                            "============================================================================
                            "File:        pep8.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000009 if exists('g:loaded_syntastic_python_pep8_checker')
                                finish
                            endif
    1              0.000006 let g:loaded_syntastic_python_pep8_checker = 1
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000006 function! SyntaxCheckers_python_pep8_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat = '%f:%l:%c: %m'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'subtype': 'Style' })
                            
                                for e in loclist
                                    let e['type'] = e['text'] =~? '^W' ? 'W' : 'E'
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000359   0.000015 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'pep8'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/prospector.vim
Sourced 1 time
Total time:   0.000786
 Self time:   0.000353

count  total (s)   self (s)
                            "============================================================================
                            "File:        prospector.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000010 if exists('g:loaded_syntastic_python_prospector_checker')
                                finish
                            endif
    1              0.000006 let g:loaded_syntastic_python_prospector_checker = 1
                            
    1              0.000006 if !exists('g:syntastic_python_prospector_sort')
    1              0.000005     let g:syntastic_python_prospector_sort = 1
    1              0.000002 endif
                            
    1              0.000015 let s:save_cpo = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000071 function! SyntaxCheckers_python_prospector_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return syntastic#util#versionIsAtLeast(self.getVersion(), [0, 7])
                            endfunction
                            
    1              0.000009 function! SyntaxCheckers_python_prospector_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': '--messages-only --absolute-paths --die-on-tool-error --zero-exit --output-format json' })
                            
                                let errorformat = '%f:%l:%c: %m'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'preprocess': 'prospector',
                                    \ 'returns': [0] })
                            
                                for e in loclist
                                    if e['text'] =~# '\v\[%(dodgy|mccabe|pep8|pep257|pyroma)\]$'
                                        let e['subtype'] = 'Style'
                                    endif
                            
                                    if e['text'] =~# '\v\[pylint\]$'
                                        let e['type'] = e['text'] =~? '\m^[CRW]' ? 'W' : 'E'
                                    elseif e['text'] =~# '\v\[%(frosted|pep8)\]$'
                                        let e['type'] = e['text'] =~? '\m^W' ? 'W' : 'E'
                                    elseif e['text'] =~# '\v\[%(dodgy|pyroma|vulture)\]$'
                                        let e['type'] = 'W'
                                    else
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000456   0.000023 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'prospector'})
                            
    1              0.000018 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/py3kwarn.vim
Sourced 1 time
Total time:   0.000548
 Self time:   0.000175

count  total (s)   self (s)
                            "============================================================================
                            "File:        py3kwarn.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Authors:     Liam Curry <liam@curry.name>
                            "
                            "============================================================================
                            
    1              0.000012 if exists('g:loaded_syntastic_python_py3kwarn_checker')
                                finish
                            endif
    1              0.000007 let g:loaded_syntastic_python_py3kwarn_checker = 1
                            
    1              0.000013 let s:save_cpo = &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000007 function! SyntaxCheckers_python_py3kwarn_GetLocList() dict
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat = '%W%f:%l:%c: %m'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env })
                            endfunction
                            
    1   0.000399   0.000026 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'py3kwarn'})
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/pylama.vim
Sourced 1 time
Total time:   0.001073
 Self time:   0.000674

count  total (s)   self (s)
                            "============================================================================
                            "File:        pylama.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000009 if exists('g:loaded_syntastic_python_pylama_checker')
                                finish
                            endif
    1              0.000007 let g:loaded_syntastic_python_pylama_checker = 1
                            
    1              0.000006 if !exists('g:syntastic_python_pylama_sort')
    1              0.000005     let g:syntastic_python_pylama_sort = 1
    1              0.000003 endif
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000006 function! SyntaxCheckers_python_pylama_GetHighlightRegex(item)
                                return SyntaxCheckers_python_pyflakes_GetHighlightRegex(a:item)
                            endfunction
                            
    1              0.000005 function! SyntaxCheckers_python_pylama_GetLocList() dict
                                if !exists('s:pylama_new')
                                    let s:pylama_new = syntastic#util#versionIsAtLeast(self.getVersion(), [4])
                                endif
                            
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': '-f pep8' . (s:pylama_new ? ' --force' : '') })
                            
                                " TODO: "WARNING:pylama:..." messages are probably a logging bug
                                let errorformat =
                                    \ '%-GWARNING:pylama:%.%#,' .
                                    \ '%A%f:%l:%c: %m'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env })
                            
                                " adjust for weirdness in each checker
                                for e in loclist
                                    let e['type'] = e['text'] =~? '\m^[RCW]' ? 'W' : 'E'
                                    if e['text'] =~# '\v\[%(mccabe|pep257|pylint)\]$'
                                        if has_key(e, 'col')
                                            let e['col'] += 1
                                        endif
                                    endif
                                    if e['text'] =~# '\v\[pylint\]$'
                                        if has_key(e, 'vcol')
                                            let e['vcol'] = 0
                                        endif
                                    endif
                                    if e['text'] =~# '\v\[%(mccabe|pep257|pep8)\]$'
                                        let e['subtype'] = 'Style'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1              0.000120 runtime! syntax_checkers/python/pyflakes.vim
                            
    1   0.000382   0.000020 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'pylama' })
                            
    1              0.000022 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/pylint.vim
Sourced 1 time
Total time:   0.000640
 Self time:   0.000283

count  total (s)   self (s)
                            "============================================================================
                            "File:        pylint.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Parantapa Bhattacharya <parantapa at gmail dot com>
                            "
                            "============================================================================
                            
    1              0.000010 if exists('g:loaded_syntastic_python_pylint_checker')
                                finish
                            endif
    1              0.000006 let g:loaded_syntastic_python_pylint_checker = 1
                            
    1              0.000005 if !exists('g:syntastic_python_pylint_sort')
    1              0.000005     let g:syntastic_python_pylint_sort = 1
    1              0.000002 endif
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000005 let s:pylint_new = -1
                            
    1              0.000006 function! SyntaxCheckers_python_pylint_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                            
                                try
                                    " On Windows the version is shown as "pylint-script.py 1.0.0".
                                    " On Gentoo Linux it's "pylint-python2.7 0.28.0".
                                    " On NixOS, that would be ".pylint-wrapped 0.26.0".
                                    " On Arch Linux it's "pylint2 1.1.0".
                                    " On new-ish Fedora it's "python3-pylint 1.2.0".
                                    " Have you guys considered switching to creative writing yet? ;)
                            
                                    let version_output = syntastic#util#system(self.getExecEscaped() . ' --version')
                                    let pylint_version = filter( split(version_output, '\m, \=\|\n'), 'v:val =~# ''\m^\(python[-0-9]*-\|\.\)\=pylint[-0-9]*\>''' )[0]
                                    let parsed_ver = syntastic#util#parseVersion(substitute(pylint_version, '\v^\S+\s+', '', ''))
                                    call self.setVersion(parsed_ver)
                            
                                    let s:pylint_new = syntastic#util#versionIsAtLeast(parsed_ver, [1])
                                catch /\m^Vim\%((\a\+)\)\=:E684/
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                    call syntastic#log#error("checker python/pylint: can't parse version string (abnormal termination?)")
                                    let s:pylint_new = -1
                                endtry
                            
                                return s:pylint_new >= 0
                            endfunction
                            
    1              0.000005 function! SyntaxCheckers_python_pylint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': (s:pylint_new ?
                                    \       '-f text --msg-template="{path}:{line}:{column}:{C}: [{symbol}] {msg}" -r n' :
                                    \       '-f parseable -r n -i y') })
                            
                                let errorformat =
                                    \ '%A%f:%l:%c:%t: %m,' .
                                    \ '%A%f:%l: %m,' .
                                    \ '%A%f:(%l): %m,' .
                                    \ '%-Z%p^%.%#,' .
                                    \ '%-G%.%#'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'returns': range(32) })
                            
                                for e in loclist
                                    if !s:pylint_new
                                        let e['type'] = e['text'][1]
                                    endif
                            
                                    if e['type'] =~? '\m^[EF]'
                                        let e['type'] = 'E'
                                    elseif e['type'] =~? '\m^[CRW]'
                                        let e['type'] = 'W'
                                    else
                                        let e['valid'] = 0
                                    endif
                            
                                    let e['col'] += 1
                                    let e['vcol'] = 0
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000373   0.000016 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'pylint' })
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/rp/.vim/bundle/syntastic/syntax_checkers/python/python.vim
Sourced 1 time
Total time:   0.000619
 Self time:   0.000263

count  total (s)   self (s)
                            "============================================================================
                            "File:        python.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000019 if exists('g:loaded_syntastic_python_python_checker')
                                finish
                            endif
    1              0.000010 let g:loaded_syntastic_python_python_checker = 1
                            
    1              0.000006 if !exists('g:syntastic_python_python_use_codec')
    1              0.000006     let g:syntastic_python_python_use_codec = 0
    1              0.000003 endif
                            
    1              0.000018 let s:save_cpo = &cpo
    1              0.000016 set cpo&vim
                            
    1   0.000046   0.000033 let s:base_path = expand('<sfile>:p:h', 1) . syntastic#util#Slash()
                            
    1              0.000008 function! SyntaxCheckers_python_python_IsAvailable() dict
                                if !executable(self.getExec())
                                    return 0
                                endif
                                return syntastic#util#versionIsAtLeast(self.getVersion(), [2, 6])
                            endfunction
                            
    1              0.000004 function! SyntaxCheckers_python_python_GetLocList() dict
                                let compiler = s:base_path . (g:syntastic_python_python_use_codec ? 'codec.py' : 'compile.py')
                                call self.log('using compiler script', compiler)
                                let makeprg = self.makeprgBuild({ 'exe': [self.getExec(), compiler] })
                            
                                let errorformat = '%E%f:%l:%c: %m'
                            
                                let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'env': env,
                                    \ 'returns': [0] })
                            endfunction
                            
    1   0.000357   0.000014 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'python',
                                \ 'name': 'python'})
                            
    1              0.000015 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

FUNCTION  GetPythonIndent()
Called 3 times
Total time:   0.001983
 Self time:   0.001983

count  total (s)   self (s)
                            
                              " If this line is explicitly joined: If the previous line was also joined,
                              " line it up with that one, otherwise add two 'shiftwidth'
    3              0.000130   if getline(a:lnum - 1) =~ '\\$'
                                if a:lnum > 1 && getline(a:lnum - 2) =~ '\\$'
                                  return indent(a:lnum - 1)
                                endif
                                return indent(a:lnum - 1) + (exists("g:pyindent_continue") ? eval(g:pyindent_continue) : (shiftwidth() * 2))
                              endif
                            
                              " If the start of the line is in a string don't change the indent.
    3              0.000113   if has('syntax_items') && synIDattr(synID(a:lnum, 1, 1), "name") =~ "String$"
                                return -1
                              endif
                            
                              " Search backwards for the previous non-empty line.
    3              0.000048   let plnum = prevnonblank(v:lnum - 1)
                            
    3              0.000014   if plnum == 0
                                " This is the first non-empty line, use zero indent.
    1              0.000005     return 0
                              endif
                            
                              " If the previous line is inside parenthesis, use the indent of the starting
                              " line.
                              " Trick: use the non-existing "dummy" variable to break out of the loop when
                              " going too far back.
    2              0.000020   call cursor(plnum, 1)
    2              0.000110   let parlnum = searchpair('(\|{\|\[', '', ')\|}\|\]', 'nbW', "line('.') < " . (plnum - s:maxoff) . " ? dummy :" . " synIDattr(synID(line('.'), col('.'), 1), 'name')" . " =~ '\\(Comment\\|Todo\\|String\\)$'")
    2              0.000011   if parlnum > 0
                                let plindent = indent(parlnum)
                                let plnumstart = parlnum
                              else
    2              0.000016     let plindent = indent(plnum)
    2              0.000010     let plnumstart = plnum
    2              0.000004   endif
                            
                            
                              " When inside parenthesis: If at the first line below the parenthesis add
                              " two 'shiftwidth', otherwise same as previous line.
                              " i = (a
                              "       + b
                              "       + c)
    2              0.000015   call cursor(a:lnum, 1)
    2              0.000327   let p = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW', "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :" . " synIDattr(synID(line('.'), col('.'), 1), 'name')" . " =~ '\\(Comment\\|Todo\\|String\\)$'")
    2              0.000013   if p > 0
                                if p == plnum
                                  " When the start is inside parenthesis, only indent one 'shiftwidth'.
                                  let pp = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW', "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :" . " synIDattr(synID(line('.'), col('.'), 1), 'name')" . " =~ '\\(Comment\\|Todo\\|String\\)$'")
                                  if pp > 0
                            	return indent(plnum) + (exists("g:pyindent_nested_paren") ? eval(g:pyindent_nested_paren) : shiftwidth())
                                  endif
                                  return indent(plnum) + (exists("g:pyindent_open_paren") ? eval(g:pyindent_open_paren) : (shiftwidth() * 2))
                                endif
                                if plnumstart == p
                                  return indent(plnum)
                                endif
                                return plindent
                              endif
                            
                            
                              " Get the line and remove a trailing comment.
                              " Use syntax highlighting attributes when possible.
    2              0.000017   let pline = getline(plnum)
    2              0.000016   let pline_len = strlen(pline)
    2              0.000021   if has('syntax_items')
                                " If the last character in the line is a comment, do a binary search for
                                " the start of the comment.  synID() is slow, a linear search would take
                                " too long on a long line.
    2              0.000094     if synIDattr(synID(plnum, pline_len, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                                  let min = 1
                                  let max = pline_len
                                  while min < max
                            	let col = (min + max) / 2
                            	if synIDattr(synID(plnum, col, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                            	  let max = col
                            	else
                            	  let min = col + 1
                            	endif
                                  endwhile
                                  let pline = strpart(pline, 0, min - 1)
                                endif
    2              0.000006   else
                                let col = 0
                                while col < pline_len
                                  if pline[col] == '#'
                            	let pline = strpart(pline, 0, col)
                            	break
                                  endif
                                  let col = col + 1
                                endwhile
                              endif
                            
                              " If the previous line ended with a colon, indent this line
    2              0.000030   if pline =~ ':\s*$'
    1              0.000011     return plindent + shiftwidth()
                              endif
                            
                              " If the previous line was a stop-execution statement...
    1              0.000025   if getline(plnum) =~ '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                                " See if the user has already dedented
                                if indent(a:lnum) > indent(plnum) - shiftwidth()
                                  " If not, recommend one dedent
                                  return indent(plnum) - shiftwidth()
                                endif
                                " Otherwise, trust the user
                                return -1
                              endif
                            
                              " If the current line begins with a keyword that lines up with "try"
    1              0.000018   if getline(a:lnum) =~ '^\s*\(except\|finally\)\>'
                                let lnum = a:lnum - 1
                                while lnum >= 1
                                  if getline(lnum) =~ '^\s*\(try\|except\)\>'
                            	let ind = indent(lnum)
                            	if ind >= indent(a:lnum)
                            	  return -1	" indent is already less than this
                            	endif
                            	return ind	" line up with previous try or except
                                  endif
                                  let lnum = lnum - 1
                                endwhile
                                return -1		" no matching "try"!
                              endif
                            
                              " If the current line begins with a header keyword, dedent
    1              0.000017   if getline(a:lnum) =~ '^\s*\(elif\|else\)\>'
                            
                                " Unless the previous line was a one-liner
                                if getline(plnumstart) =~ '^\s*\(for\|if\|try\)\>'
                                  return plindent
                                endif
                            
                                " Or the user has already dedented
                                if indent(a:lnum) <= plindent - shiftwidth()
                                  return -1
                                endif
                            
                                return plindent - shiftwidth()
                              endif
                            
                              " When after a () construct we probably want to go back to the start line.
                              " a = (b
                              "       + c)
                              " here
    1              0.000004   if parlnum > 0
                                return plindent
                              endif
                            
    1              0.000003   return -1
                            

FUNCTION  <SNR>3_SynSet()
Called 1 time
Total time:   0.002888
 Self time:   0.000836

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000008   syn clear
    1              0.000005   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    1              0.000005   let s = expand("<amatch>")
    1              0.000003   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    1              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    2              0.000014     for name in split(s, '\.')
    1   0.002787   0.000735       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000004     endfor
    1              0.000003   endif

FUNCTION  airline#extensions#branch#head()
Called 91 times
Total time:   0.006224
 Self time:   0.003085

count  total (s)   self (s)
   91              0.000938   if exists('b:airline_head') && !empty(b:airline_head)
   86              0.000353     return b:airline_head
                              endif
                            
    5              0.000085   let b:airline_head = ''
    5              0.000031   let found_fugitive_head = 0
                            
    5              0.000041   if s:has_fugitive && !exists('b:mercurial_dir')
    5   0.003208   0.000113     let b:airline_head = fugitive#head(7)
    5              0.000028     let found_fugitive_head = 1
                            
    5              0.000040     if empty(b:airline_head) && !exists('b:git_dir')
                                  let b:airline_head = s:get_git_branch(expand("%:p:h"))
                                endif
    5              0.000013   endif
                            
    5              0.000025   if empty(b:airline_head)
                                if s:has_lawrencium
                                  let b:airline_head = lawrencium#statusline()
                                endif
                              endif
                            
    5              0.000024   if empty(b:airline_head)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = get(b:VCSCommandBufferInfo, 0, '')
                                  endif
                                endif
                              endif
                            
    5              0.000049   if empty(b:airline_head) || !found_fugitive_head && !s:check_in_path()
                                let b:airline_head = ''
                              endif
                            
    5   0.000147   0.000103   let b:airline_head = s:format_name(b:airline_head)
                            
    5              0.000047   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:w:displayed_head_limit - 1].'…'
                                endif
                              endif
                            
    5              0.000020   return b:airline_head

FUNCTION  <SNR>66_get_section()
Called 22 times
Total time:   0.001980
 Self time:   0.001722

count  total (s)   self (s)
   22              0.000165   if has_key(s:section_truncate_width, a:key)
   16              0.000120     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
   16              0.000037   endif
   22              0.000123   let spc = g:airline_symbols.space
   22   0.000652   0.000394   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   22              0.000310   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   22              0.000182   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>25__os_name()
Called 6 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    6              0.000033     return g:_SYNTASTIC_UNAME

FUNCTION  4()
Called 3 times
Total time:   0.000625
 Self time:   0.000102

count  total (s)   self (s)
    3   0.000137   0.000044     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    3   0.000471   0.000041     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  8()
Called 3 times
Total time:   0.022569
 Self time:   0.021884

count  total (s)   self (s)
    3              0.000019     unlet! b:syntastic_private_balloons
    3   0.000211   0.000055     if self.enabled() && !a:loclist.isEmpty()
    3   0.000582   0.000053         let b:syntastic_private_balloons = a:loclist.balloons()
    3              0.000022         if !empty(b:syntastic_private_balloons)
    3              0.021675             set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
    3              0.000020         endif
    3              0.000009     endif

FUNCTION  9()
Called 3 times
Total time:   0.000234
 Self time:   0.000144

count  total (s)   self (s)
    3              0.000019     let b:syntastic_private_balloons = {}
    3              0.000016     if has('balloon_eval')
    3   0.000119   0.000029         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
    3              0.000013         unlet! b:syntastic_private_balloons
    3              0.000034         set noballooneval
    3              0.000007     endif

FUNCTION  <SNR>38_AllowQuote()
Called 2 times
Total time:   0.000278
 Self time:   0.000224

count  total (s)   self (s)
    2              0.000013     let l:result = 1
    2              0.000009     if b:AutoCloseSmartQuote
    2              0.000014         let l:initPos = 1 + (a:isBS ? 1 : 0)
    2   0.000087   0.000033         let l:charBehind = s:GetCharBehind(l:initPos)
    2              0.000011         let l:prev = l:charBehind
    2              0.000010         let l:backSlashCount = 0
    2              0.000012         while l:charBehind == '\'
                                        let l:backSlashCount = l:backSlashCount + 1
                                        let l:charBehind = s:GetCharBehind(l:initPos + l:backSlashCount)
                                    endwhile
                            
    2              0.000008         if l:backSlashCount % 2
                                        let l:result = 0
                                    else
    2              0.000010             if a:char == "'" && l:prev =~ '[a-zA-Z0-9]'
                                            let l:result = 0
                                        endif
    2              0.000005         endif
    2              0.000005     endif
    2              0.000007     return l:result

FUNCTION  <SNR>38_GetCurrentSyntaxRegion()
Called 2 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    2              0.000042     return synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')

FUNCTION  syntastic#util#wideMsg()
Called 2 times
Total time:   0.029533
 Self time:   0.000354

count  total (s)   self (s)
    2              0.000014     let old_ruler = &ruler
    2              0.000011     let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
    2              0.000029     let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
    2              0.000023     let chunks = split(msg, "\t", 1)
    2              0.000036     let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
    2              0.000019     let msg = strpart(msg, 0, &columns - 1)
                            
    2              0.000033     set noruler noshowcmd
    2   0.029219   0.000040     call syntastic#util#redraw(0)
                            
    2              0.000055     echo msg
                            
    2              0.000021     let &ruler = old_ruler
    2              0.000013     let &showcmd = old_showcmd

FUNCTION  32()
Called 3 times
Total time:   0.000164
 Self time:   0.000099

count  total (s)   self (s)
    3   0.000093   0.000028     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    3              0.000025     autocmd! syntastic CursorMoved
    3              0.000012     unlet! b:syntastic_private_messages
    3              0.000015     let b:syntastic_private_line = -1

FUNCTION  34()
Called 6 times
Total time:   0.000263
 Self time:   0.000109

count  total (s)   self (s)
    6   0.000243   0.000089     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  35()
Called 3 times
Total time:   0.001271
 Self time:   0.000925

count  total (s)   self (s)
    3   0.000154   0.000031     if self.enabled()
    3   0.000148   0.000048         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    3   0.000122   0.000033         call self._reset()
    3              0.000024         let buf = bufnr('')
    3   0.000097   0.000063         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    6              0.000029         for item in issues
    3              0.000043             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
    3              0.000017             if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
    3              0.000015                 if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
    3              0.000032                     let lastcol = col([item['lnum'], '$'])
    3              0.000014                     let coltype = 'c'
    3              0.000007                 endif
    3              0.000029                 let lcol = min([lastcol, item['col']])
                            
    3              0.000112                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
    3              0.000014             endif
    3              0.000010         endfor
    3              0.000009     endif

FUNCTION  36()
Called 3 times
Total time:   0.000291
 Self time:   0.000107

count  total (s)   self (s)
    3              0.000012     if s:has_highlighting
    3   0.000107   0.000041         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    3   0.000144   0.000026         call self._reset()
    3              0.000006     endif

FUNCTION  38()
Called 6 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
    8              0.000055     for match in getmatches()
    2              0.000013         if stridx(match['group'], 'Syntastic') == 0
    2              0.000014             call matchdelete(match['id'])
    2              0.000005         endif
    2              0.000004     endfor

FUNCTION  39()
Called 9 times
Total time:   0.001140
 Self time:   0.001140

count  total (s)   self (s)
    9              0.000257     let newObj = copy(self)
                            
    9              0.000134     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
   15              0.000065     for e in llist
    6              0.000044         if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
    6              0.000016     endfor
                            
    9              0.000051     let newObj._rawLoclist = llist
    9              0.000041     let newObj._name = ''
    9              0.000053     let newObj._owner = bufnr('')
    9              0.000044     let newObj._sorted = 0
    9              0.000055     let newObj._columns = g:syntastic_cursor_columns
                            
    9              0.000032     return newObj

FUNCTION  <SNR>14_repo()
Called 10 times
Total time:   0.000795
 Self time:   0.000795

count  total (s)   self (s)
   10              0.000188   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   10              0.000044   if dir !=# ''
   10              0.000080     if has_key(s:repos, dir)
   10              0.000081       let repo = get(s:repos, dir)
   10              0.000030     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
   10              0.000160     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  airline#util#exec_funcrefs()
Called 2 times
Total time:   0.006403
 Self time:   0.000614

count  total (s)   self (s)
   14              0.000055     for Fn in a:list
   14   0.006098   0.000309       let code = call(Fn, a:000)
   14              0.000050       if code != 0
    2              0.000007         return code
                                  endif
   12              0.000031     endfor
                                return 0

FUNCTION  7()
Called 6 times
Total time:   0.000263
 Self time:   0.000112

count  total (s)   self (s)
    6   0.000244   0.000093     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  airline#highlighter#highlight()
Called 13 times
Total time:   0.261878
 Self time:   0.092410

count  total (s)   self (s)
   13              0.000147   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   13              0.000332   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   13              0.000134   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   34              0.000161   for mode in mapped
   21              0.000264     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   21              0.000193       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  275              0.001282       for kvp in items(dict)
  254              0.001662         let mode_colors = kvp[1]
  254   0.025262   0.004082         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
  762              0.003859         for accent in keys(s:accents)
  508              0.003264           if !has_key(p.accents, accent)
                                        continue
                                      endif
  508              0.003974           let colors = copy(mode_colors)
  508              0.003525           if p.accents[accent][0] != ''
  254              0.001978             let colors[0] = p.accents[accent][0]
  254              0.000677           endif
  508              0.002730           if p.accents[accent][2] != ''
  254              0.001773             let colors[2] = p.accents[accent][2]
  254              0.000662           endif
  508              0.002247           if len(colors) >= 5
  172              0.001507             let colors[4] = get(p.accents[accent], 4, '')
  172              0.000490           else
  336              0.003038             call add(colors, get(p.accents[accent], 4, ''))
  336              0.000851           endif
  508   0.052398   0.008279           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
  508              0.001693         endfor
  254              0.000658       endfor
                            
                                  " TODO: optimize this
  168              0.000718       for sep in items(s:separators)
  147   0.107132   0.002963         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  147              0.000467       endfor
   21              0.000047     endif
   21              0.000045   endfor

FUNCTION  <SNR>59_update()
Called 53 times
Total time:   0.004329
 Self time:   0.004329

count  total (s)   self (s)
   53              0.002181   if match(&ft, s:filetypes) > -1
                                if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick
                                  " cache data
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_wordcount_cache = b:airline_wordcount
                                  let b:airline_change_tick = b:changedtick
                                endif
                              endif

FUNCTION  <SNR>25_BufWritePostHook()
Called 3 times
Total time:   0.222616
 Self time:   0.000174

count  total (s)   self (s)
    3   0.000191   0.000092     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
    3   0.222401   0.000058     call s:UpdateErrors(1, [])

FUNCTION  airline#extensions#unite#apply()
Called 2 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000029   if &ft == 'unite'
                                call a:1.add_section('airline_a', ' Unite ')
                                call a:1.add_section('airline_b', ' %{get(unite#get_context(), "buffer_name", "")} ')
                                call a:1.add_section('airline_c', ' %{unite#get_status_string()} ')
                                call a:1.split()
                                call a:1.add_section('airline_y', ' %{get(unite#get_context(), "real_buffer_name", "")} ')
                                return 1
                              endif

FUNCTION  airline#parts#ffenc()
Called 91 times
Total time:   0.003527
 Self time:   0.003527

count  total (s)   self (s)
   91              0.003245   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  airline#extensions#quickfix#apply()
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000016   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  <SNR>38_IsForbidden()
Called 2 times
Total time:   0.000519
 Self time:   0.000188

count  total (s)   self (s)
    2   0.000118   0.000066     let l:result = index(b:AutoCloseProtectedRegions, s:GetCurrentSyntaxRegion()) >= 0
    2              0.000008     if l:result
                                    return l:result
                                endif
    2   0.000325   0.000046     let l:region = s:GetCurrentSyntaxRegionIf(a:char)
    2              0.000020     let l:result = index(b:AutoCloseProtectedRegions, l:region) >= 0
    2              0.000012     return l:result || l:region == 'Comment'

FUNCTION  40()
Called 97 times
Total time:   0.002774
 Self time:   0.002774

count  total (s)   self (s)
   97              0.001042     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
   97              0.000475     return b:syntastic_loclist

FUNCTION  41()
Called 3 times
Total time:   0.000606
 Self time:   0.000148

count  total (s)   self (s)
    3   0.000072   0.000039     let list = self.copyRaw()
    3   0.000074   0.000044     call extend(list, a:other.copyRaw())
    3   0.000434   0.000039     return g:SyntasticLoclist.New(list)

FUNCTION  43()
Called 18 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
   18              0.000129     return empty(self._rawLoclist)

FUNCTION  44()
Called 9 times
Total time:   0.000817
 Self time:   0.000312

count  total (s)   self (s)
    9              0.000067     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    9   0.000623   0.000118     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  45()
Called 9 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    9              0.000066     return copy(self._rawLoclist)

FUNCTION  47()
Called 6 times
Total time:   0.000836
 Self time:   0.000183

count  total (s)   self (s)
    6   0.000815   0.000162     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  48()
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000016     return self._columns

FUNCTION  49()
Called 91 times
Total time:   0.016873
 Self time:   0.016690

count  total (s)   self (s)
   91              0.000769     if !exists('self._stl_format')
    3              0.000014         let self._stl_format = ''
    3              0.000006     endif
   91              0.000488     if !exists('self._stl_flag')
    3              0.000012         let self._stl_flag = ''
    3              0.000006     endif
                            
   91              0.000553     if g:syntastic_stl_format !=# self._stl_format
    3              0.000012         let self._stl_format = g:syntastic_stl_format
                            
    3              0.000009         if !empty(self._rawLoclist)
    3   0.000082   0.000025             let errors = self.errors()
    3   0.000079   0.000025             let warnings = self.warnings()
                            
    3              0.000014             let num_errors = len(errors)
    3              0.000013             let num_warnings = len(warnings)
    3              0.000013             let num_issues = len(self._rawLoclist)
                            
    3              0.000012             let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
    3              0.000051             let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
    3              0.000038             let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
    3              0.000037             let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
    3              0.000271             let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
    3   0.000233   0.000161             let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
    3              0.000013             let self._stl_flag = output
    3              0.000007         else
                                        let self._stl_flag = ''
                                    endif
    3              0.000006     endif
                            
   91              0.000383     return self._stl_flag

FUNCTION  <SNR>38_GetCharAhead()
Called 10 times
Total time:   0.000193
 Self time:   0.000193

count  total (s)   self (s)
   10              0.000083     if col('$') == col('.')
    9              0.000035         return "\0"
                                endif
    1              0.000012     return strpart(getline('.'), col('.')-2 + a:len, 1)

FUNCTION  <SNR>38_Backspace()
Called 3 times
Total time:   0.001225
 Self time:   0.000550

count  total (s)   self (s)
    3              0.000111     let l:save_ve = &ve
    3   0.000276   0.000073     let l:prev = s:GetPrevChar()
    3   0.000146   0.000045     let l:next = s:GetNextChar()
    3              0.000067     set ve=all
                            
    3   0.000432   0.000061     if b:AutoCloseOn && s:IsEmptyPair() && (l:prev != l:next || s:AllowQuote(l:prev, 1))
                                    call s:EraseNCharsAtCursor(1)
                                    call s:PopBuffer()
                                endif
                            
    3              0.000064     exec "set ve=" . l:save_ve
    3              0.000021     return "\<BS>"

FUNCTION  <SNR>61_exec_separator()
Called 161 times
Total time:   0.113984
 Self time:   0.013679

count  total (s)   self (s)
  161   0.047481   0.002131   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  161   0.046002   0.002185   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  161              0.001157   let group = a:from.'_to_'.a:to.a:suffix
  161              0.000487   if a:inverse
   46              0.000427     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   46              0.000117   else
  115              0.001094     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  115              0.000295   endif
  161              0.000959   let a:dict[group] = colors
  161   0.013005   0.001867   call airline#highlighter#exec(group, colors)

FUNCTION  airline#themes#get_highlight()
Called 322 times
Total time:   0.089167
 Self time:   0.005142

count  total (s)   self (s)
  322   0.088291   0.004266   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  syntastic#log#debug()
Called 74 times
Total time:   0.002106
 Self time:   0.001364

count  total (s)   self (s)
   74   0.001521   0.000779     if !s:_isDebugEnabled(a:level)
   74              0.000254         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>38_FlushBuffer()
Called 3 times
Total time:   0.000444
 Self time:   0.000359

count  total (s)   self (s)
    3              0.000059     let l:result = ''
    3              0.000038     if exists("b:AutoCloseBuffer")
    1              0.000010         let l:len = len(b:AutoCloseBuffer)
    1              0.000006         if l:len > 0
    1              0.000021             let l:result = join(b:AutoCloseBuffer, '') . repeat("\<Left>", l:len)
    1              0.000007             let b:AutoCloseBuffer = []
    1   0.000144   0.000059             call s:EraseNCharsAtCursor(l:len)
    1              0.000003         endif
    1              0.000003     endif
    3              0.000019     return l:result

FUNCTION  <SNR>58_check_mixed_indent()
Called 8 times
Total time:   0.000559
 Self time:   0.000559

count  total (s)   self (s)
    8              0.000055   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif s:indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    8              0.000218     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  airline#highlighter#add_separator()
Called 14 times
Total time:   0.010224
 Self time:   0.000409

count  total (s)   self (s)
   14              0.000151   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   14   0.010020   0.000205   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  syntastic#log#debugShowOptions()
Called 3 times
Total time:   0.000068
 Self time:   0.000046

count  total (s)   self (s)
    3   0.000048   0.000026     if !s:_isDebugEnabled(a:level)
    3              0.000006         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#statusline()
Called 91 times
Total time:   0.003255
 Self time:   0.003255

count  total (s)   self (s)
   91              0.001217   if has_key(s:contexts, a:winnr)
   91              0.001462     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>43_Highlight_Matching_Pair()
Called 92 times
Total time:   0.040469
 Self time:   0.040469

count  total (s)   self (s)
                              " Remove any previous match.
   92              0.001118   if exists('w:paren_hl_on') && w:paren_hl_on
   24              0.000263     silent! call matchdelete(3)
   24              0.000179     let w:paren_hl_on = 0
   24              0.000119   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   92              0.000988   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   92              0.000745   let c_lnum = line('.')
   92              0.000605   let c_col = col('.')
   92              0.000408   let before = 0
                            
   92              0.000706   let text = getline(c_lnum)
   92              0.003362   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   92              0.000608   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   92              0.001086     let [c_before, c] = matches[1:2]
   92              0.000294   endif
   92              0.002827   let plist = split(&matchpairs, '.\zs[:,]')
   92              0.000949   let i = index(plist, c)
   92              0.000370   if i < 0
                                " not found, in Insert mode try character before the cursor
   70              0.000610     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   52              0.000446       let before = strlen(c_before)
   52              0.000258       let c = c_before
   52              0.000337       let i = index(plist, c)
   52              0.000149     endif
   70              0.000240     if i < 0
                                  " not found, nothing to do
   68              0.000223       return
                                endif
    2              0.000006   endif
                            
                              " Figure out the arguments for searchpairpos().
   24              0.000091   if i % 2 == 0
    1              0.000006     let s_flags = 'nW'
    1              0.000010     let c2 = plist[i + 1]
    1              0.000003   else
   23              0.000111     let s_flags = 'nbW'
   23              0.000114     let c2 = c
   23              0.000190     let c = plist[i - 1]
   23              0.000070   endif
   24              0.000116   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   24              0.000092   if before > 0
    2              0.000020     let has_getcurpos = exists("*getcurpos")
    2              0.000008     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    2              0.000016       let save_cursor = getcurpos()
    2              0.000005     else
                                  let save_cursor = winsaveview()
                                endif
    2              0.000020     call cursor(c_lnum, c_col - before)
    2              0.000006   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   24              0.000292   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
   24              0.002214   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   24              0.000213   let stoplinebottom = line('w$')
   24              0.000226   let stoplinetop = line('w0')
   24              0.000106   if i % 2 == 0
    1              0.000008     let stopline = stoplinebottom
    1              0.000003   else
   23              0.000158     let stopline = stoplinetop
   23              0.000061   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   24              0.000161   if mode() == 'i' || mode() == 'R'
   22              0.000313     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   22              0.000062   else
    2              0.000020     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000005   endif
   24              0.000093   try
   24              0.002518     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   24              0.000129   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   24              0.000104   if before > 0
    2              0.000007     if has_getcurpos
    2              0.000018       call setpos('.', save_cursor)
    2              0.000005     else
                                  call winrestview(save_cursor)
                                endif
    2              0.000006   endif
                            
                              " If a match is found setup match highlighting.
   24              0.000177   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   24              0.000167     if exists('*matchaddpos')
   24              0.000696       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   24              0.000081     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   24              0.000139     let w:paren_hl_on = 1
   24              0.000063   endif

FUNCTION  52()
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000023     let self._name = a:name

FUNCTION  fugitive#head()
Called 5 times
Total time:   0.003095
 Self time:   0.000294

count  total (s)   self (s)
    5              0.000057   if !exists('b:git_dir')
                                return ''
                              endif
                            
    5   0.002970   0.000169   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  54()
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000040     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  55()
Called 3 times
Total time:   0.000950
 Self time:   0.000257

count  total (s)   self (s)
    3   0.000095   0.000042     call self.setOwner(bufnr(''))
    3   0.000203   0.000058     let self._stamp = syntastic#util#stamp()
    6   0.000551   0.000056     for buf in self.getBuffers()
    3              0.000039         call setbufvar(buf, 'syntastic_loclist', self)
    3              0.000010     endfor

FUNCTION  56()
Called 3 times
Total time:   0.000447
 Self time:   0.000106

count  total (s)   self (s)
    6   0.000378   0.000037     for buf in self.getBuffers()
    3              0.000026         call setbufvar(buf, 'syntastic_loclist', {})
    3              0.000007     endfor

FUNCTION  58()
Called 3 times
Total time:   0.000529
 Self time:   0.000529

count  total (s)   self (s)
    3              0.000024     if !exists('self._cachedBalloons')
    3              0.000026         let sep = has('balloon_multiline') ? "\n" : ' | '
                            
    3              0.000019         let self._cachedBalloons = {}
    6              0.000026         for e in self._rawLoclist
    3              0.000017             let buf = e['bufnr']
                            
    3              0.000023             if !has_key(self._cachedBalloons, buf)
    3              0.000026                 let self._cachedBalloons[buf] = {}
    3              0.000010             endif
                            
    3              0.000026             if has_key(self._cachedBalloons[buf], e['lnum'])
                                            let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
                                        else
    3              0.000036                 let self._cachedBalloons[buf][e['lnum']] = e['text']
    3              0.000010             endif
    3              0.000008         endfor
    3              0.000008     endif
                            
    3              0.000033     return get(self._cachedBalloons, bufnr(''), {})

FUNCTION  59()
Called 9 times
Total time:   0.000547
 Self time:   0.000259

count  total (s)   self (s)
    9              0.000059     if !exists('self._cachedErrors')
    3   0.000341   0.000053         let self._cachedErrors = self.filter({'type': 'E'})
    3              0.000011     endif
    9              0.000033     return self._cachedErrors

FUNCTION  68()
Called 3 times
Total time:   0.000208
 Self time:   0.000129

count  total (s)   self (s)
    3              0.000031     let fts = split(a:filetype, '\m\.')
                            
    3   0.000057   0.000033     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    3   0.000081   0.000026         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  airline#update_statusline()
Called 2 times
Total time:   0.032209
 Self time:   0.000546

count  total (s)   self (s)
    2   0.000062   0.000037   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    2              0.000033   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            
    2              0.000010   unlet! w:airline_render_left
    2              0.000006   unlet! w:airline_render_right
   20              0.000063   for section in s:sections
   18              0.000092     unlet! w:airline_section_{section}
   18              0.000043   endfor
                            
    2              0.000010   let w:airline_active = 1
    2              0.000024   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    2   0.031687   0.000049   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>65_get_transitioned_seperator()
Called 14 times
Total time:   0.010933
 Self time:   0.000709

count  total (s)   self (s)
   14              0.000066   let line = ''
   14   0.010404   0.000180   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   14              0.000118   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   14              0.000106   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   14              0.000074   let line .= '%#'.a:group.'#'
   14              0.000042   return line

FUNCTION  5()
Called 3 times
Total time:   0.000430
 Self time:   0.000241

count  total (s)   self (s)
    3   0.000127   0.000042     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    3   0.000116   0.000042     let auto_loc_list = syntastic#util#var('auto_loc_list')
    3   0.000064   0.000034     if !a:loclist.isEmpty()
    3              0.000018         if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
    3              0.000008     else
                                    if auto_loc_list == 1 || auto_loc_list == 2
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
                                        lclose
                                    endif
                                endif

FUNCTION  syntastic#util#wformat()
Called 6 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    6              0.000026     if a:format ==# ''
    6              0.000016         return a:str
                                endif
                            
                             echomsg string(a:format) . ', ' . string(a:str)
                                let specs = matchlist(a:format, '\v^(-?)(0?)(%([1-9]\d*))?%(\.(\d+))?$')
                                if len(specs) < 5
                                    return a:str
                                endif
                            
                                let flushleft = specs[1] ==# '-'
                                let lpad = specs[2] ==# '0' ? '0' : ' '
                                let minlen = str2nr(specs[3])
                                let maxlen = str2nr(specs[4])
                                let out = substitute(a:str, "\t", ' ', 'g')
                            
                                if maxlen && s:_width(out) > maxlen
                                    let chars = filter(split(out, '\zs\ze', 1), 'v:val !=# ""')
                                    let out = ''
                            
                                    if flushleft
                                        for c in chars
                                            if s:_width(out . c) < maxlen
                                                let out .= c
                                            else
                                                let out .= &encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '>'
                                                break
                                            endif
                                        endfor
                                    else
                                        call reverse(chars)
                                        for c in chars
                                            if s:_width(c . out) < maxlen
                                                let out = c . out
                                            else
                                                let out = (&encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '<') . out
                                                break
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if minlen && s:_width(out) < minlen
                                    if flushleft
                                        let out .= repeat(' ', minlen - s:_width(out))
                                    else
                                        let out = repeat(lpad, minlen - s:_width(out)) . out
                                    endif
                                endif
                            
                                return out

FUNCTION  airline#parts#readonly()
Called 91 times
Total time:   0.000919
 Self time:   0.000919

count  total (s)   self (s)
   91              0.000617   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  <SNR>51_sync_active_winnr()
Called 13 times
Total time:   0.000389
 Self time:   0.000389

count  total (s)   self (s)
   13              0.000229   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  94()
Called 3 times
Total time:   0.003957
 Self time:   0.000268

count  total (s)   self (s)
    3   0.000135   0.000045     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
    3   0.000127   0.000050     let old_signs = copy(self._bufSignIds())
    3   0.000196   0.000029     if self.enabled()
    3   0.002850   0.000059         call self._signErrors(a:loclist)
    3              0.000008     endif
    3   0.000614   0.000050     call self._removeSigns(old_signs)

FUNCTION  60()
Called 9 times
Total time:   0.000475
 Self time:   0.000245

count  total (s)   self (s)
    9              0.000061     if !exists('self._cachedWarnings')
    3   0.000280   0.000050         let self._cachedWarnings = self.filter({'type': 'W'})
    3              0.000010     endif
    9              0.000031     return self._cachedWarnings

FUNCTION  62()
Called 3 times
Total time:   0.001817
 Self time:   0.001296

count  total (s)   self (s)
    3              0.000026     if !exists('self._cachedMessages')
    3              0.000021         let self._cachedMessages = {}
                            
    3   0.000214   0.000061         let errors = self.errors() + self.warnings()
    6              0.000027         for e in errors
    3              0.000017             let b = e['bufnr']
    3              0.000015             let l = e['lnum']
                            
    3              0.000025             if !has_key(self._cachedMessages, b)
    3              0.000025                 let self._cachedMessages[b] = {}
    3              0.000009             endif
                            
    3              0.000023             if !has_key(self._cachedMessages[b], l)
    3              0.000027                 let self._cachedMessages[b][l] = [e]
    3              0.000016             elseif self._columns
                                            call add(self._cachedMessages[b][l], e)
                                        endif
    3              0.000009         endfor
                            
    3              0.000011         if self._columns
    3              0.000011             if !self._sorted
    6              0.000032                 for b in keys(self._cachedMessages)
    6              0.000032                     for l in keys(self._cachedMessages[b])
    3              0.000021                         if len(self._cachedMessages[b][l]) > 1
                                                        for e in self._cachedMessages[b][l]
                                                            call s:_set_screen_column(e)
                                                        endfor
                                                        call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
                                                    endif
    3              0.000007                     endfor
    3              0.000007                 endfor
    3              0.000007             endif
                            
    6              0.000030             for b in keys(self._cachedMessages)
    6              0.000031                 for l in keys(self._cachedMessages[b])
    3   0.000433   0.000065                     call s:_remove_shadowed_items(self._cachedMessages[b][l])
    3              0.000009                 endfor
    3              0.000008             endfor
    3              0.000008         endif
    3              0.000006     endif
                            
    3              0.000029     return get(self._cachedMessages, a:buf, {})

FUNCTION  63()
Called 6 times
Total time:   0.000518
 Self time:   0.000418

count  total (s)   self (s)
    6   0.000300   0.000200     let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
    6              0.000087     let filter = len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
    6              0.000093     return filter(copy(self._rawLoclist), filter)

FUNCTION  67()
Called 3 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    3              0.000018     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    3              0.000013         let self._mode = 'active'
    3              0.000011         let self._activeFiletypes = []
    3              0.000010         let self._passiveFiletypes = []
    3              0.000007     endif

FUNCTION  69()
Called 3 times
Total time:   0.000306
 Self time:   0.000098

count  total (s)   self (s)
    3              0.000022     let local_mode = get(b:, 'syntastic_mode', '')
    3              0.000012     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    3   0.000237   0.000029     return self.allowsAutoChecking(&filetype)

FUNCTION  <SNR>38_InsertPair()
Called 2 times
Total time:   0.001539
 Self time:   0.000484

count  total (s)   self (s)
    2   0.000610   0.000091     if ! b:AutoCloseOn || ! has_key(b:AutoClosePairs, a:opener) || s:IsForbidden(a:opener)
                                  return a:opener
                                endif
                            
    2              0.000021     let l:save_ve = &ve
    2              0.000042     set ve=all
                            
    2   0.000126   0.000035     let l:next = s:GetNextChar()
                                " only add closing pair before space or any of the closepair chars
    2              0.000062     let close_before = '\s\|\V\[,.;' . escape(join(keys(b:AutoClosePairs) + values(b:AutoClosePairs), ''), ']').']'
    2   0.000320   0.000042     if (l:next == "\0" || l:next =~ close_before) && s:AllowQuote(a:opener, 0)
    2   0.000151   0.000042         call s:InsertStringAtCursor(b:AutoClosePairs[a:opener])
    2   0.000092   0.000034         call s:PushBuffer(b:AutoClosePairs[a:opener])
    2              0.000005     endif
                            
    2              0.000034     exec "set ve=" . l:save_ve
    2              0.000009     return a:opener

FUNCTION  airline#extensions#undotree#apply()
Called 2 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    2              0.000015   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{t:undotree.GetStatusLine()}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{t:diffpanel.GetStatusLine()}')
                                endif
                              endif

FUNCTION  <SNR>38_GetNextChar()
Called 10 times
Total time:   0.000373
 Self time:   0.000180

count  total (s)   self (s)
   10   0.000343   0.000150     return s:GetCharAhead(1)

FUNCTION  154()
Called 8 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    8              0.000067   call add(self._sections, ['', a:text])

FUNCTION  <SNR>14_repo_dir()
Called 10 times
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
   10              0.000190   return join([self.git_dir]+a:000,'/')

FUNCTION  airline#util#getwinvar()
Called 28 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
   28              0.000240     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>67__isDebugEnabled_smart()
Called 86 times
Total time:   0.000833
 Self time:   0.000833

count  total (s)   self (s)
   86              0.000571     return and(g:syntastic_debug, a:level)

FUNCTION  UndotreeUpdate()
Called 20 times
Total time:   0.000499
 Self time:   0.000499

count  total (s)   self (s)
   20              0.000279     if !exists('t:undotree')
   20              0.000085         return
                                endif
                                if !exists('w:undotree_id')
                                    let w:undotree_id = 'id_'.s:getUniqueID()
                                    call s:log("Unique window id assigned: ".w:undotree_id)
                                endif
                                " assume window layout won't change during updating.
                                let thiswinnr = winnr()
                                call t:undotree.Update()
                                " focus moved
                                if winnr() != thiswinnr
                                    call s:exec("norm! ".thiswinnr."\<c-w>\<c-w>")
                                endif

FUNCTION  syntastic#util#unique()
Called 9 times
Total time:   0.000941
 Self time:   0.000941

count  total (s)   self (s)
    9              0.000059     let seen = {}
    9              0.000039     let uniques = []
   23              0.000086     for e in a:list
   14              0.000095         let k = string(e)
   14              0.000077         if !has_key(seen, k)
    9              0.000052             let seen[k] = 1
    9              0.000056             call add(uniques, e)
    9              0.000023         endif
   14              0.000034     endfor
    9              0.000031     return uniques

FUNCTION  <SNR>25__ignore_file()
Called 6 times
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
    6              0.000095     let fname = fnamemodify(a:filename, ':p')
    6              0.000033     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    6              0.000013     return 0

FUNCTION  <SNR>61_get_array()
Called 346 times
Total time:   0.011486
 Self time:   0.011486

count  total (s)   self (s)
  346              0.001716   let fg = a:fg
  346              0.001210   let bg = a:bg
  346              0.006637   return has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  30()
Called 6 times
Total time:   0.000246
 Self time:   0.000094

count  total (s)   self (s)
    6   0.000226   0.000074     return syntastic#util#var('echo_current_error')

FUNCTION  31()
Called 3 times
Total time:   0.002580
 Self time:   0.000431

count  total (s)   self (s)
    3   0.000205   0.000055     if self.enabled() && !a:loclist.isEmpty()
    3   0.000205   0.000048         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
    3   0.001931   0.000114         let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
    3              0.000021         let b:syntastic_private_line = -1
    3   0.000078   0.000053         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
    3              0.000038         autocmd! syntastic CursorMoved
    3              0.000050         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    3              0.000010     endif

FUNCTION  70()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000014     return self._mode ==# 'passive'

FUNCTION  <SNR>20__translate()
Called 6 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    6              0.000078     return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)

FUNCTION  75()
Called 3 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    3              0.000046     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  77()
Called 3 times
Total time:   0.035633
 Self time:   0.002838

count  total (s)   self (s)
    3   0.000374   0.000070     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    3   0.000135   0.000047     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   18              0.000085     for type in self._enabled_types
   15              0.000405         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   15   0.000996   0.000447         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   15              0.000138             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    6              0.000058                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    6   0.000650   0.000108                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    6   0.026645   0.000119                     call self._notifier[type].refresh(a:loclist)
    6   0.000465   0.000155                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    6              0.000026                 endif
    6              0.000015             else
    9   0.004650   0.000174                 call self._notifier[type].refresh(a:loclist)
    9              0.000025             endif
   15              0.000040         endif
   15              0.000037     endfor

FUNCTION  78()
Called 3 times
Total time:   0.001903
 Self time:   0.001148

count  total (s)   self (s)
    3   0.000097   0.000031     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   18              0.000056     for type in self._enabled_types
   15              0.000241         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   15              0.000103         if has_key(g:{class}, 'reset')
    9   0.000785   0.000096             call self._notifier[type].reset(a:loclist)
    9              0.000017         endif
                            
                                    " also reset stamps
   15              0.000080         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    6              0.000044             let b:syntastic_private_{type}_stamp = []
    6              0.000012         endif
   15              0.000038     endfor

FUNCTION  <SNR>18__find_index()
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000019     let max = len(a:messages) - 1
    2              0.000008     if max == 0
    2              0.000006         return 0
                                endif
                                let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
                                while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
                                return a:column < a:messages[max].scol ? min : max

FUNCTION  <SNR>27_on_window_changed()
Called 2 times
Total time:   0.032369
 Self time:   0.000131

count  total (s)   self (s)
    2              0.000023   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
    2   0.000080   0.000051   call s:init()
    2   0.032240   0.000031   call airline#update_statusline()

FUNCTION  syntastic#log#debugDump()
Called 3 times
Total time:   0.000065
 Self time:   0.000043

count  total (s)   self (s)
    3   0.000046   0.000024     if !s:_isDebugEnabled(a:level)
    3              0.000006         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  airline#extensions#wordcount#apply()
Called 2 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    2              0.000087   if &ft =~ s:filetypes
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  <SNR>38_GetCharBehind()
Called 10 times
Total time:   0.000388
 Self time:   0.000388

count  total (s)   self (s)
   10              0.000100     if col('.') == 1
                                    return "\0"
                                endif
   10              0.000155     return strpart(getline('.'), col('.') - (1 + a:len), 1)

FUNCTION  airline#util#wrap()
Called 637 times
Total time:   0.012463
 Self time:   0.012463

count  total (s)   self (s)
  637              0.004154   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  637              0.002179   return a:text

FUNCTION  airline#highlighter#get_highlight()
Called 346 times
Total time:   0.089981
 Self time:   0.025584

count  total (s)   self (s)
  346   0.030921   0.004089   let fg = s:get_syn(a:group, 'fg')
  346   0.030308   0.004229   let bg = s:get_syn(a:group, 'bg')
  346              0.009895   let reverse = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  346   0.016514   0.005028   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 91 times
Total time:   0.024383
 Self time:   0.002883

count  total (s)   self (s)
   91   0.022687   0.001187   let errors = SyntasticStatuslineFlag()
   91              0.000565   if strlen(errors) > 0
   76              0.000464     return errors.(g:airline_symbols.space)
                              endif
   15              0.000037   return ''

FUNCTION  <SNR>38_EmptyBuffer()
Called 4 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
    4              0.000072     if exists("b:AutoCloseBuffer")
    1              0.000011         let b:AutoCloseBuffer = []
    1              0.000004     endif

FUNCTION  SyntaxCheckers_python_python_GetLocList()
Called 3 times
Total time:   0.123535
 Self time:   0.000312

count  total (s)   self (s)
    3              0.000024     let compiler = s:base_path . (g:syntastic_python_python_use_codec ? 'codec.py' : 'compile.py')
    3   0.000216   0.000034     call self.log('using compiler script', compiler)
    3   0.003184   0.000062     let makeprg = self.makeprgBuild({ 'exe': [self.getExec(), compiler] })
                            
    3              0.000013     let errorformat = '%E%f:%l:%c: %m'
                            
    3   0.000107   0.000047     let env = syntastic#util#isRunningWindows() ? {} : { 'TERM': 'dumb' }
                            
    3   0.119947   0.000088     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'env': env, 'returns': [0] })

FUNCTION  airline#parts#paste()
Called 91 times
Total time:   0.000982
 Self time:   0.000982

count  total (s)   self (s)
   91              0.000699   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>38_InsertStringAtCursor()
Called 2 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
    2              0.000016     let l:line = getline('.')
    2              0.000014     let l:column = col('.')-2
                            
    2              0.000008     if l:column < 0
                                    call setline('.', a:str . l:line)
                                else
    2              0.000030         call setline('.', l:line[:l:column] . a:str . l:line[l:column+1:])
    2              0.000007     endif

FUNCTION  80()
Called 11 times
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
   11              0.000074     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
   11              0.000044     return s:SyntasticRegistryInstance

FUNCTION  81()
Called 11 times
Total time:   0.003917
 Self time:   0.000898

count  total (s)   self (s)
   11   0.000431   0.000141     let registry = g:SyntasticRegistry.Instance()
                            
   11              0.000055     if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
                                else
   11   0.002086   0.000114         let checker = g:SyntasticChecker.New(a:args)
   11              0.000023     endif
   11   0.000855   0.000098     call registry._registerChecker(checker)

FUNCTION  82()
Called 3 times
Total time:   0.037644
 Self time:   0.000299

count  total (s)   self (s)
    3   0.000142   0.000042     let ft = s:_normalise_filetype(a:ftalias)
    3   0.037123   0.000031     call self._loadCheckersFor(ft)
                            
    3              0.000020     let checkers_map = self._checkerMap[ft]
    3              0.000012     if empty(checkers_map)
                                    return []
                                endif
                            
    3   0.000101   0.000029     call self._checkDeprecation(ft)
                            
    3              0.000055     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, 0)
                            
    3   0.000131   0.000050     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]

FUNCTION  88()
Called 11 times
Total time:   0.000757
 Self time:   0.000616

count  total (s)   self (s)
   11   0.000174   0.000102     let ft = a:checker.getFiletype()
   11              0.000055     if !has_key(self._checkerMap, ft)
    1              0.000005         let self._checkerMap[ft] = {}
    1              0.000002     endif
                            
   11   0.000162   0.000093     let name = a:checker.getName()
   11              0.000060     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
   11              0.000062     let self._checkerMap[ft][name] = a:checker

FUNCTION  89()
Called 3 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    3              0.000068     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )

FUNCTION  syntastic#util#system()
Called 4 times
Total time:   0.128298
 Self time:   0.001203

count  total (s)   self (s)
    4              0.000021     let old_shell = &shell
    4              0.000022     let old_lc_messages = $LC_MESSAGES
    4              0.000017     let old_lc_all = $LC_ALL
                            
    4   0.000113   0.000045     let &shell = syntastic#util#var('shell')
    4              0.000027     let $LC_MESSAGES = 'C'
    4              0.000016     let $LC_ALL = ''
                            
    4   0.127687   0.000660     let out = system(a:command)
                            
    4              0.000098     let $LC_ALL = old_lc_all
    4              0.000027     let $LC_MESSAGES = old_lc_messages
                            
    4              0.000080     let &shell = old_shell
                            
    4              0.000032     return out

FUNCTION  <SNR>38_Space()
Called 2 times
Total time:   0.000481
 Self time:   0.000141

count  total (s)   self (s)
    2   0.000420   0.000080     if b:AutoCloseOn && s:IsEmptyPair()
                                    call s:PushBuffer("\<Space>")
                                    return "\<Space>\<Space>\<Left>"
                                else
    2              0.000013         return "\<Space>"
                                endif

FUNCTION  airline#parts#mode()
Called 91 times
Total time:   0.001033
 Self time:   0.001033

count  total (s)   self (s)
   91              0.000746   return get(w:, 'airline_current_mode', '')

FUNCTION  airline#extensions#default#apply()
Called 2 times
Total time:   0.004748
 Self time:   0.000310

count  total (s)   self (s)
    2              0.000016   let winnr = a:context.winnr
    2              0.000012   let active = a:context.active
                            
    2   0.000052   0.000029   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    2   0.001447   0.000042     call s:build_sections(a:builder, a:context, s:layout[0])
    2              0.000005   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    2   0.000248   0.000051   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    2   0.000046   0.000024   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    2   0.002821   0.000030     call s:build_sections(a:builder, a:context, s:layout[1])
    2              0.000005   endif
                            
    2              0.000007   return 1

FUNCTION  <SNR>20__remove_shadowed_items()
Called 3 times
Total time:   0.000368
 Self time:   0.000368

count  total (s)   self (s)
                                " keep only the first message at a given column
    3              0.000020     let i = 0
    3              0.000026     while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            
                                " merge messages with the same text
    3              0.000014     let i = 0
    3              0.000022     while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile

FUNCTION  airline#check_mode()
Called 91 times
Total time:   0.285894
 Self time:   0.021304

count  total (s)   self (s)
   91              0.000956   let context = s:contexts[a:winnr]
                            
   91              0.000709   if get(w:, 'airline_active', 1)
   91              0.000610     let l:m = mode()
   91              0.000414     if l:m ==# "i"
   52              0.000285       let l:mode = ['insert']
   52              0.000182     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
   39              0.000224       let l:mode = ['normal']
   39              0.000100     endif
   91              0.000969     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   91              0.000250   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   91              0.000599   if g:airline_detect_modified && &modified
   61              0.000479     call add(l:mode, 'modified')
   61              0.000165   endif
                            
   91              0.000418   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   91              0.000863   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   91              0.000374   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   91              0.000923   let mode_string = join(l:mode)
   91              0.000787   if get(w:, 'airline_lastmode', '') != mode_string
   13   0.002957   0.000245     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   13   0.262120   0.000242     call airline#highlighter#highlight(l:mode)
   13              0.000072     let w:airline_lastmode = mode_string
   13              0.000026   endif
                            
   91              0.000276   return ''

FUNCTION  <SNR>66_add_section()
Called 16 times
Total time:   0.003476
 Self time:   0.001325

count  total (s)   self (s)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   16   0.000564   0.000207     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   16              0.000084     if (a:key == 'warning' || a:key == 'error')
    4   0.000099   0.000051       call a:builder.add_raw('%(')
    4              0.000011     endif
   16   0.002082   0.000381     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   16              0.000098     if (a:key == 'warning' || a:key == 'error')
    4   0.000086   0.000041       call a:builder.add_raw('%)')
    4              0.000010     endif

FUNCTION  <SNR>61_get_syn()
Called 692 times
Total time:   0.052911
 Self time:   0.052911

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
  692              0.010543   let mode = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? 'gui' : 'cterm'
  692              0.008600   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
  692              0.003621   if empty(color) || color == -1
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
                              endif
  692              0.002913   if empty(color) || color == -1
                                if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
                                  let color = a:what ==# 'fg' ? 0 : 1
                                endif
                              endif
  692              0.002130   return color

FUNCTION  airline#highlighter#exec()
Called 936 times
Total time:   0.077855
 Self time:   0.077855

count  total (s)   self (s)
  936              0.005798   let colors = a:colors
  936              0.003519   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  936              0.045048   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') isnot# '' ? 'guifg='.colors[0] : '', get(colors, 1, '') isnot# '' ? 'guibg='.colors[1] : '', get(colors, 2, '') isnot# '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') isnot# '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') isnot# '' ? 'gui='.colors[4] : '', get(colors, 4, '') isnot# '' ? 'cterm='.colors[4] : '', get(colors, 4, '') isnot# '' ? 'term='.colors[4] : '')

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 13 times
Total time:   0.002712
 Self time:   0.001294

count  total (s)   self (s)
   13              0.000147   if getbufvar(a:bufnr, '&modified')
    8              0.000224     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    8              0.000028   else
    5              0.000124     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    5              0.000016   endif
                            
   13              0.000063   if !empty(colors)
   13   0.001706   0.000288     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   13              0.000045   endif

FUNCTION  <SNR>25_ClearCache()
Called 3 times
Total time:   0.002532
 Self time:   0.000116

count  total (s)   self (s)
    3   0.002013   0.000044     call s:notifiers.reset(g:SyntasticLoclist.current())
    3   0.000508   0.000061     call b:syntastic_loclist.destroy()

FUNCTION  airline#extensions#branch#get_head()
Called 91 times
Total time:   0.010947
 Self time:   0.004723

count  total (s)   self (s)
   91   0.007356   0.001132   let head = airline#extensions#branch#head()
   91              0.000822   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   91              0.000857   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   91              0.001206   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  90()
Called 3 times
Total time:   0.037092
 Self time:   0.029321

count  total (s)   self (s)
    3              0.000018     if has_key(self._checkerMap, a:filetype)
    2              0.000004         return
                                endif
                            
    1   0.037033   0.029262     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
    1              0.000008     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  91()
Called 3 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    3              0.000031     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  93()
Called 6 times
Total time:   0.000312
 Self time:   0.000129

count  total (s)   self (s)
    6   0.000291   0.000108     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  96()
Called 3 times
Total time:   0.002791
 Self time:   0.001919

count  total (s)   self (s)
    3              0.000023     let loclist = a:loclist
    3   0.000061   0.000032     if !loclist.isEmpty()
                            
    3              0.000021         let buf = bufnr('')
    3              0.000017         if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
    3   0.000454   0.000044         let issues = copy(loclist.errors())
    3   0.000399   0.000051         call extend(issues, loclist.warnings())
    3              0.000033         call filter(issues, 'v:val["bufnr"] == buf')
    3              0.000017         let seen = {}
                            
    6              0.000026         for i in issues
    3              0.000031             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
    3              0.000028                 let seen[i['lnum']] = 1
                            
    3              0.000027                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
    3              0.000025                 let sign_subtype = get(i, 'subtype', '')
    3              0.000025                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
    3              0.001116                 execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
    3   0.000148   0.000063                 call add(self._bufSignIds(), s:next_sign_id)
    3              0.000026                 let s:next_sign_id += 1
    3              0.000010             endif
    3              0.000007         endfor
    3              0.000009     endif

FUNCTION  97()
Called 3 times
Total time:   0.000564
 Self time:   0.000463

count  total (s)   self (s)
    3              0.000029     if has('signs')
    5              0.000035         for s in reverse(copy(a:ids))
    2              0.000254             execute 'sign unplace ' . s
    2   0.000154   0.000053             call remove(self._bufSignIds(), index(self._bufSignIds(), s))
    2              0.000006         endfor
    3              0.000009     endif

FUNCTION  98()
Called 10 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   10              0.000095     if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
   10              0.000046     return b:syntastic_private_sign_ids

FUNCTION  airline#parts#filetype()
Called 91 times
Total time:   0.000745
 Self time:   0.000745

count  total (s)   self (s)
   91              0.000463   return &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 2 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    2              0.000022   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  <SNR>9_LoadFTPlugin()
Called 1 time
Total time:   0.002001
 Self time:   0.001543

count  total (s)   self (s)
    1              0.000008     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    1              0.000008     let s = expand("<amatch>")
    1              0.000004     if s != ""
    1              0.000021       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000013       for name in split(s, '\.')
    1   0.001898   0.001440 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    1              0.000004       endfor
    1              0.000002     endif

FUNCTION  <SNR>14_sub()
Called 5 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
    5              0.000228   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  airline#parts#iminsert()
Called 91 times
Total time:   0.001932
 Self time:   0.001932

count  total (s)   self (s)
   91              0.000632   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   91              0.000248   return ''

FUNCTION  26()
Called 3 times
Total time:   0.000673
 Self time:   0.000442

count  total (s)   self (s)
                                " wildcard quiet_messages
    3   0.000126   0.000051     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    3              0.000023     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    3              0.000023     let name = self._filetype . '_' . self._name
    3              0.000010     try
    3   0.000140   0.000078         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    3              0.000010     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    3   0.000140   0.000046     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    3              0.000017     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  <SNR>14_repo_head()
Called 5 times
Total time:   0.002372
 Self time:   0.000614

count  total (s)   self (s)
    5   0.001689   0.000177     let head = s:repo().head_ref()
                            
    5              0.000113     if head =~# '^ref: '
    5   0.000352   0.000106       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
    5              0.000024     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
    5              0.000020     return branch

FUNCTION  151()
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000020   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  syntastic#util#versionIsAtLeast()
Called 1 time
Total time:   0.000093
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000090   0.000017     return syntastic#util#compareLexi(a:installed, a:required) >= 0

FUNCTION  <SNR>25__is_quitting()
Called 6 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
    6              0.000027     let quitting = 0
    6              0.000028     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    6              0.000016     return quitting

FUNCTION  syntastic#util#shexpand()
Called 3 times
Total time:   0.000108
 Self time:   0.000047

count  total (s)   self (s)
    3   0.000100   0.000039     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  syntastic#util#Slash()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000008     return (!exists('+shellslash') || &shellslash) ? '/' : '\'

FUNCTION  <SNR>56_format_name()
Called 5 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    5              0.000029     return a:name

FUNCTION  <SNR>51_is_excluded_window()
Called 2 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
    2              0.000015   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
    8              0.000032   for matchw in g:airline_exclude_filenames
    6              0.000090     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
    6              0.000014   endfor
                            
    2              0.000009   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    2              0.000006   return 0

FUNCTION  <SNR>65_get_accented_line()
Called 16 times
Total time:   0.002228
 Self time:   0.002228

count  total (s)   self (s)
   16              0.000070   if a:self._context.active
   16              0.000074     let contents = []
   16              0.000240     let content_parts = split(a:contents, '__accent')
   40              0.000149     for cpart in content_parts
   24              0.000420       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   24              0.000156       call add(contents, cpart)
   24              0.000058     endfor
   16              0.000116     let line = join(contents, a:group)
   16              0.000229     let line = substitute(line, '__restore__', a:group, 'g')
   16              0.000043   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   16              0.000048   return line

FUNCTION  <SNR>18__is_same_index()
Called 12 times
Total time:   0.000442
 Self time:   0.000442

count  total (s)   self (s)
   12              0.000103     if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
    8              0.000048         if len(a:messages) <= 1
    8              0.000029             return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
    4              0.000014         return 0
                                endif

FUNCTION  17()
Called 3 times
Total time:   0.125766
 Self time:   0.000129

count  total (s)   self (s)
    3   0.125756   0.000119     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  <SNR>38_EraseNCharsAtCursor()
Called 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000013     let l:line = getline('.')
    1              0.000011     let l:column = col('.')-2
                            
    1              0.000005     if l:column < 0
                                    call setline('.', l:line[a:len + 1:])
                                else
    1              0.000027         call setline('.', l:line[:l:column] . l:line[l:column + a:len + 1:])
    1              0.000004     endif

FUNCTION  SyntaxCheckers_python_python_IsAvailable()
Called 1 time
Total time:   0.012261
 Self time:   0.000095

count  total (s)   self (s)
    1   0.000044   0.000036     if !executable(self.getExec())
                                    return 0
                                endif
    1   0.012206   0.000048     return syntastic#util#versionIsAtLeast(self.getVersion(), [2, 6])

FUNCTION  <SNR>66_build_sections()
Called 4 times
Total time:   0.004196
 Self time:   0.000720

count  total (s)   self (s)
   20              0.000075   for key in a:keys
   16              0.000107     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
   16   0.003705   0.000229     call s:add_section(a:builder, a:context, key)
   16              0.000044   endfor

FUNCTION  <SNR>25__resolve_filetypes()
Called 3 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    3              0.000025     let type = len(a:filetypes) ? a:filetypes[0] : &filetype
    3              0.000034     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  <SNR>10_LoadIndent()
Called 1 time
Total time:   0.000965
 Self time:   0.000401

count  total (s)   self (s)
    1              0.000006     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    1              0.000006     let s = expand("<amatch>")
    1              0.000004     if s != ""
    1              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000012       for name in split(s, '\.')
    1   0.000893   0.000329 	exe 'runtime! indent/' . name . '.vim'
    1              0.000003       endfor
    1              0.000002     endif

FUNCTION  SyntasticRefreshCursor()
Called 12 times
Total time:   0.032256
 Self time:   0.002239

count  total (s)   self (s)
   12              0.000167     if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
                                    return
                                endif
                            
   12              0.000085     if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
   12              0.000079     let l = line('.')
   12              0.000166     let current_messages = get(b:syntastic_private_messages, l, {})
                            
   12              0.000093     if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
   12              0.000050     if b:syntastic_cursor_columns
   12              0.000088         let c = virtcol('.')
   12              0.000132         if !exists('b:syntastic_private_idx')
    1              0.000007             let b:syntastic_private_idx = -1
    1              0.000003         endif
                            
   12   0.000721   0.000279         if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
    8              0.000025             return
                                    else
    4              0.000026             let b:syntastic_private_line = l
    4              0.000011         endif
                            
    4              0.000022         if !empty(current_messages)
    2   0.000095   0.000053             let b:syntastic_private_idx = s:_find_index(c, current_messages)
    2   0.029587   0.000054             call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
    2              0.000007         else
    2              0.000012             let b:syntastic_private_idx = -1
    2              0.000014             echo
    2              0.000004         endif
    4              0.000009     else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  syntastic#util#argsescape()
Called 45 times
Total time:   0.001350
 Self time:   0.001197

count  total (s)   self (s)
   45              0.000274     if type(a:opt) == type('') && a:opt !=# ''
    3              0.000009         return [a:opt]
                                elseif type(a:opt) == type([])
    3   0.000217   0.000064         return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
   39              0.000090     return []

FUNCTION  airline#parts#crypt()
Called 91 times
Total time:   0.001395
 Self time:   0.001395

count  total (s)   self (s)
   91              0.001086   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#whitespace#check()
Called 91 times
Total time:   0.017203
 Self time:   0.016644

count  total (s)   self (s)
   91              0.001011   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                return ''
                              endif
                            
   91              0.000638   if !exists('b:airline_whitespace_check')
    8              0.000051     let b:airline_whitespace_check = ''
    8              0.000072     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    8              0.000035     let trailing = 0
    8              0.000053     if index(checks, 'trailing') > -1
    8              0.000029       try
    8              0.000062         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    8              0.000210         let trailing = search(regexp, 'nw')
    8              0.000030       catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    8              0.000019     endif
                            
    8              0.000035     let mixed = 0
    8              0.000047     if index(checks, 'indent') > -1
    8   0.000680   0.000121       let mixed = s:check_mixed_indent()
    8              0.000028     endif
                            
    8              0.000035     let long = 0
    8              0.000052     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    8              0.000039     if trailing != 0 || mixed != 0 || long != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                    if long != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:long_format, long)
                                    endif
                                  endif
                                endif
    8              0.000020   endif
   91              0.000446   return b:airline_whitespace_check

FUNCTION  <SNR>27_init()
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000012   if s:airline_initialized
    2              0.000005     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  syntastic#util#isRunningWindows()
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000049     return has('win16') || has('win32') || has('win64')

FUNCTION  SyntasticStatuslineFlag()
Called 91 times
Total time:   0.021500
 Self time:   0.002020

count  total (s)   self (s)
   91   0.021225   0.001745     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  155()
Called 2 times
Total time:   0.024902
 Self time:   0.003434

count  total (s)   self (s)
    2              0.000011   let side = 1
    2              0.000007   let line = ''
    2              0.000007   let i = 0
    2              0.000013   let length = len(self._sections)
    2              0.000008   let split = 0
                            
   28              0.000087   while i < length
   26              0.000138     let section = self._sections[i]
   26              0.000132     let group = section[0]
   26              0.000125     let contents = section[1]
   26   0.001477   0.000327     let prev_group = s:get_prev_group(self._sections, i)
                            
   26              0.000086     if group == ''
    8              0.000041       let line .= contents
    8              0.000023     elseif group == '|'
    2              0.000008       let side = 0
    2              0.000013       let line .= contents
    2              0.000007       let split = 1
    2              0.000004     else
   16              0.000052       if prev_group == ''
    2              0.000014         let line .= '%#'.group.'#'
    2              0.000006       elseif split
    2   0.001715   0.000033         let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    2              0.000008         let split = 0
    2              0.000004       else
   12   0.016578   0.000170         let line .= s:get_seperator(self, prev_group, group, side)
   12              0.000034       endif
   16   0.002522   0.000294       let line .= s:get_accented_line(self, group, contents)
   16              0.000043     endif
                            
   26              0.000120     let i = i + 1
   26              0.000068   endwhile
                            
    2              0.000006   if !self._context.active
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    2              0.000009   return line

FUNCTION  <SNR>14_repo_head_ref()
Called 5 times
Total time:   0.001146
 Self time:   0.000919

count  total (s)   self (s)
    5   0.000453   0.000357   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
    5   0.000624   0.000493   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>25__skip_file()
Called 6 times
Total time:   0.001029
 Self time:   0.000549

count  total (s)   self (s)
    6              0.000042     let fname = expand('%', 1)
    6   0.000869   0.000389     let skip = s:_is_quitting(bufnr('%')) || get(b:, 'syntastic_skip_checks', 0) || (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    6              0.000020     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    6              0.000016     return skip

FUNCTION  SyntasticMake()
Called 3 times
Total time:   0.119859
 Self time:   0.002711

count  total (s)   self (s)
    3   0.000102   0.000034     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    3              0.000018     let old_local_errorformat = &l:errorformat
    3              0.000015     let old_errorformat = &errorformat
    3              0.000025     let old_cwd = getcwd()
                                " }}}3
                            
    3              0.000015     if has_key(a:options, 'errorformat')
    3              0.000036         let &errorformat = a:options['errorformat']
    3              0.000020         set errorformat<
    3              0.000007     endif
                            
    3              0.000014     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    3              0.000011     let env_save = {}
    3              0.000017     if has_key(a:options, 'env') && len(a:options['env'])
    6              0.000027         for key in keys(a:options['env'])
    3              0.000037             if key =~? '\m^[a-z_]\+$'
    3              0.000037                 execute 'let env_save[' . string(key) . '] = $' . key
    3              0.000043                 execute 'let $' . key . ' = ' . string(a:options['env'][key])
    3              0.000008             endif
    3              0.000006         endfor
    3              0.000006     endif
                                " }}}3
                            
    3   0.116874   0.000163     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    3              0.000028     if len(env_save)
    6              0.000040         for key in keys(env_save)
    3              0.000078             execute 'let $' . key . ' = ' . string(env_save[key])
    3              0.000012         endfor
    3              0.000008     endif
                                " }}}3
                            
    3   0.000217   0.000072     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    3   0.000167   0.000082     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    3              0.000012     if !bailout
    3              0.000014         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    3              0.000271         lgetexpr err_lines
                            
    3              0.000078         let errors = deepcopy(getloclist(0))
                            
    3              0.000019         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    3              0.000010         try
    3              0.000142             silent lolder
    2              0.000007         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
    1              0.000015             call setloclist(0, [], 'r')
    1              0.000005         catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    3              0.000008     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    3              0.000045     let &errorformat = old_errorformat
    3              0.000025     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    3   0.000176   0.000122     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    3              0.000008     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
    3   0.000127   0.000042     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    3              0.000017     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
    3              0.000012     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    3              0.000069     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
    3              0.000010     return errors

FUNCTION  <SNR>23__normalise_filetype()
Called 3 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    3              0.000026     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    3              0.000017     let ft = get(g:syntastic_filetype_map, ft, ft)
    3              0.000028     let ft = substitute(ft, '\m-', '_', 'g')
    3              0.000009     return ft

FUNCTION  <SNR>65_should_change_group()
Called 12 times
Total time:   0.006767
 Self time:   0.000811

count  total (s)   self (s)
   12              0.000063   if a:group1 == a:group2
                                return 0
                              endif
   12   0.003165   0.000133   let color1 = airline#highlighter#get_highlight(a:group1)
   12   0.003065   0.000141   let color2 = airline#highlighter#get_highlight(a:group2)
   12              0.000141   if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   12              0.000092     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>38_GetPrevChar()
Called 8 times
Total time:   0.000487
 Self time:   0.000153

count  total (s)   self (s)
    8   0.000460   0.000126     return s:GetCharBehind(1)

FUNCTION  10()
Called 11 times
Total time:   0.001972
 Self time:   0.001972

count  total (s)   self (s)
   11              0.000163     let newObj = copy(self)
                            
   11              0.000067     let newObj._filetype = a:args['filetype']
   11              0.000056     let newObj._name = a:args['name']
                            
   11              0.000028     if a:0
                                    " redirected checker
                                    let newObj._exec = get(a:args, 'exec', a:1['_exec'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
                                else
   11              0.000072         let newObj._exec = get(a:args, 'exec', newObj._name)
   11              0.000076         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
   11              0.000044         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
   11              0.000021     endif
                            
   11              0.000088     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
   11              0.000069     if exists('*' . prefix . 'IsAvailable')
    3              0.000023         let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
    3              0.000006     else
    8              0.000070         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
    8              0.000020     endif
                            
   11              0.000066     if exists('*' . prefix . 'GetHighlightRegex')
    3              0.000024         let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
    3              0.000006     endif
                            
   11              0.000026     return newObj

FUNCTION  11()
Called 14 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
   14              0.000054     return self._filetype

FUNCTION  12()
Called 14 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   14              0.000052     return self._name

FUNCTION  13()
Called 3 times
Total time:   0.000188
 Self time:   0.000143

count  total (s)   self (s)
    3   0.000111   0.000066     let user_exec = expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec : syntastic#util#var(self._filetype . '_' . self._name . '_exec'), 1 )
                            
    3              0.000014     if user_exec !=# '' && user_exec !=# self._exec
                                    let self._exec = user_exec
                                    if has_key(self, '_available')
                                        " we have a new _exec on the block, it has to be validated
                                        call remove(self, '_available')
                                    endif
                                endif

FUNCTION  14()
Called 5 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    5              0.000020     return self._exec

FUNCTION  15()
Called 4 times
Total time:   0.000171
 Self time:   0.000057

count  total (s)   self (s)
    4   0.000162   0.000048     return syntastic#util#shescape(self._exec)

FUNCTION  16()
Called 3 times
Total time:   0.125127
 Self time:   0.000638

count  total (s)   self (s)
    3              0.000019     let name = self._filetype . '/' . self._name
                            
    3              0.000014     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
    3              0.000009     try
    3   0.123600   0.000065         let list = self._locListFunc()
    3              0.000024         if self._exec !=# ''
    3   0.000140   0.000058             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    3              0.000008         endif
    3              0.000008     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    3   0.000170   0.000050     call self._populateHighlightRegexes(list)
    3   0.000121   0.000042     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    3   0.000721   0.000048     call self._quietMessages(list)
    3              0.000011     return list

FUNCTION  18()
Called 1 time
Total time:   0.012065
 Self time:   0.000176

count  total (s)   self (s)
    1              0.000005     if !exists('self._version')
    1   0.000075   0.000012         let command = a:0 ? a:1 : self.getExecEscaped() . ' --version'
    1   0.011611   0.000024         let version_output = syntastic#util#system(command)
    1   0.000142   0.000056         call self.log('getVersion: ' . string(command) . ': ' . string(split(version_output, "\n", 1)) . (v:shell_error ? ' (exit code ' . v:shell_error . ')' : '') )
    1   0.000068   0.000019         let parsed_ver = syntastic#util#parseVersion(version_output)
    1              0.000006         if len(parsed_ver)
    1   0.000118   0.000014             call self.setVersion(parsed_ver)
    1              0.000002         else
                                        call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                        call syntastic#log#error("checker " . self._filetype . "/" . self._name . ": can't parse version string (abnormal termination?)")
                                    endif
    1              0.000001     endif
    1              0.000005     return get(self, '_version', [])

FUNCTION  19()
Called 1 time
Total time:   0.000104
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000005     if len(a:version)
    1              0.000008         let self._version = copy(a:version)
    1   0.000084   0.000015         call self.log(self.getExec() . ' version =', a:version)
    1              0.000002     endif

FUNCTION  syntastic#util#redraw()
Called 2 times
Total time:   0.029179
 Self time:   0.029179

count  total (s)   self (s)
    2              0.000010     if a:full
                                    redraw!
                                else
    2              0.029139         redraw
    2              0.000007     endif

FUNCTION  <SNR>65_get_seperator()
Called 12 times
Total time:   0.016408
 Self time:   0.000390

count  total (s)   self (s)
   12   0.006916   0.000149   if s:should_change_group(a:prev_group, a:group)
   12   0.009440   0.000189     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  syntastic#log#debugShowVariables()
Called 6 times
Total time:   0.000139
 Self time:   0.000092

count  total (s)   self (s)
    6   0.000098   0.000051     if !s:_isDebugEnabled(a:level)
    6              0.000014         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  syntastic#util#stamp()
Called 9 times
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
    9              0.000419     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  airline#util#append()
Called 364 times
Total time:   0.012257
 Self time:   0.012257

count  total (s)   self (s)
  364              0.002387   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  364              0.003144   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  364              0.002682   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>38_GetCurrentSyntaxRegionIf()
Called 2 times
Total time:   0.000279
 Self time:   0.000279

count  total (s)   self (s)
    2              0.000018     let l:origin_line = getline('.')
    2              0.000037     let l:changed_line = strpart(l:origin_line, 0, col('.')-1) . a:char . strpart(l:origin_line, col('.')-1)
    2              0.000036     call setline('.', l:changed_line)
    2              0.000116     let l:region = synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')
    2              0.000020     call setline('.', l:origin_line)
    2              0.000028     return l:region

FUNCTION  syntastic#util#parseVersion()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000047     return map(split(matchstr( a:version, a:0 ? a:1 : '\v^\D*\zs\d+(\.\d+)+\ze' ), '\m\.'), 'str2nr(v:val)')

FUNCTION  <SNR>25_CacheErrors()
Called 3 times
Total time:   0.184037
 Self time:   0.002178

count  total (s)   self (s)
    3   0.000108   0.000041     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    3   0.002561   0.000029     call s:ClearCache()
    3   0.000280   0.000045     let newLoclist = g:SyntasticLoclist.New([])
                            
    3   0.000502   0.000027     if !s:_skip_file()
                                    " debug logging {{{3
    3   0.000101   0.000033         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    3   0.000109   0.000044         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    3   0.000110   0.000046         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    3   0.000117   0.000047         let filetypes = s:_resolve_filetypes([])
    3   0.000093   0.000042         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
    3              0.000018         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    3              0.000018         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    3              0.000010         let clist = []
    6              0.000020         for type in filetypes
    3   0.037695   0.000051             call extend(clist, s:registry.getCheckers(type, a:checker_names))
    3              0.000010         endfor
                            
    3              0.000011         let names = []
    3              0.000013         let unavailable_checkers = 0
    3              0.000012         for checker in clist
    3   0.000088   0.000044             let cname = checker.getFiletype() . '/' . checker.getName()
    3   0.012602   0.000031             if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
    3   0.000101   0.000034             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    3   0.125832   0.000066             let loclist = checker.getLocList()
                            
    3   0.000075   0.000043             if !loclist.isEmpty()
    3              0.000013                 if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
    3              0.000024                 call add(names, cname)
    3   0.000178   0.000040                 if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
    3   0.000745   0.000139                 let newLoclist = newLoclist.extend(loclist)
                            
    3              0.000014                 if !aggregate_errors
    3              0.000010                     break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
    3              0.000016         if !empty(names)
    3   0.000459   0.000171             if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
    3              0.000087                 let type = substitute(names[0], '\m/.*', '', '')
    3              0.000091                 let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
    3   0.000086   0.000053                 call newLoclist.setName( name . ' ('. type . ')' )
    3              0.000011             else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
    3              0.000007         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    3              0.000019         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    3   0.000141   0.000048         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    3              0.000011         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    3              0.000007     endif
                            
    3   0.000984   0.000034     call newLoclist.deploy()

FUNCTION  <SNR>25_UpdateErrors()
Called 3 times
Total time:   0.222343
 Self time:   0.001160

count  total (s)   self (s)
    3   0.000111   0.000040     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    3   0.000124   0.000056     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
    3   0.000096   0.000031     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    3   0.000111   0.000048     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    3   0.000168   0.000030     call s:modemap.synch()
                            
    3   0.000584   0.000030     if s:_skip_file()
                                    return
                                endif
                            
    3   0.000344   0.000038     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
    3              0.000009     if run_checks
    3   0.184146   0.000109         call s:CacheErrors(a:checker_names)
    3              0.000019         unlockvar! b:syntastic_changedtick
    3              0.000022         let b:syntastic_changedtick = b:changedtick
    3              0.000016         lockvar! b:syntastic_changedtick
    3              0.000007     else
                                    if a:auto_invoked
                                        return
                                    endif
                                endif
                            
    3   0.000157   0.000056     let loclist = g:SyntasticLoclist.current()
                            
    3              0.000023     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    3   0.000119   0.000046     let do_jump = syntastic#util#var('auto_jump') + 0
    3              0.000014     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    3              0.000019     let w:syntastic_loclist_set = 0
    3   0.000110   0.000036     if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
                                    call setloclist(0, loclist.getRaw())
                                    let w:syntastic_loclist_set = 1
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
    3   0.035698   0.000065     call s:notifiers.refresh(loclist)

FUNCTION  syntastic#util#var()
Called 70 times
Total time:   0.001549
 Self time:   0.001549

count  total (s)   self (s)
   70              0.001322     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  <SNR>28_invoke_funcrefs()
Called 2 times
Total time:   0.031638
 Self time:   0.000212

count  total (s)   self (s)
    2   0.000154   0.000033   let builder = airline#builder#new(a:context)
    2   0.006458   0.000055   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    2              0.000007   if err == 1
    2   0.024941   0.000039     let a:context.line = builder.build()
    2              0.000017     let s:contexts[a:context.winnr] = a:context
    2              0.000033     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    2              0.000006   endif

FUNCTION  syntastic#util#compareLexi()
Called 10 times
Total time:   0.000578
 Self time:   0.000578

count  total (s)   self (s)
   11              0.000152     for idx in range(max([len(a:a), len(a:b)]))
   11              0.000111         let a_element = str2nr(get(a:a, idx, 0))
   11              0.000106         let b_element = str2nr(get(a:b, idx, 0))
   11              0.000051         if a_element != b_element
   10              0.000053             return a_element > b_element ? 1 : -1
                                    endif
    1              0.000002     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  <SNR>38_PushBuffer()
Called 2 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    2              0.000017     if !exists("b:AutoCloseBuffer")
    1              0.000008         let b:AutoCloseBuffer = []
    1              0.000003     endif
    2              0.000014     call insert(b:AutoCloseBuffer, a:char)

FUNCTION  <SNR>38_IsEmptyPair()
Called 5 times
Total time:   0.000711
 Self time:   0.000246

count  total (s)   self (s)
    5   0.000369   0.000085     let l:prev = s:GetPrevChar()
    5   0.000251   0.000070     let l:next = s:GetNextChar()
    5              0.000055     return (l:next != "\0") && (get(b:AutoClosePairs, l:prev, "\0") == l:next)

FUNCTION  airline#extensions#apply()
Called 2 times
Total time:   0.000563
 Self time:   0.000268

count  total (s)   self (s)
    2              0.000016   let s:active_winnr = winnr()
                            
    2   0.000326   0.000031   if s:is_excluded_window()
                                return -1
                              endif
                            
    2              0.000009   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    2              0.000007   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    2              0.000028   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    2              0.000014   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>65_get_prev_group()
Called 26 times
Total time:   0.001150
 Self time:   0.001150

count  total (s)   self (s)
   26              0.000148   let x = a:i - 1
   36              0.000119   while x >= 0
   34              0.000215     let group = a:sections[x][0]
   34              0.000153     if group != '' && group != '|'
   24              0.000066       return group
                                endif
   10              0.000035     let x = x - 1
   10              0.000027   endwhile
    2              0.000006   return ''

FUNCTION  20()
Called 5 times
Total time:   0.000330
 Self time:   0.000195

count  total (s)   self (s)
    5              0.000037     let leader = self._filetype . '/' . self._name . ': '
    5              0.000017     if a:0 > 0
    4   0.000143   0.000047         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
    4              0.000008     else
    1   0.000054   0.000015         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
    1              0.000002     endif

FUNCTION  21()
Called 3 times
Total time:   0.003101
 Self time:   0.000327

count  total (s)   self (s)
    3              0.000020     let basename = self._filetype . '_' . self._name . '_'
                            
    3              0.000009     let parts = []
    3   0.000874   0.000059     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
    3   0.000504   0.000036     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
    3   0.000602   0.000059     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
    3   0.000525   0.000036     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
    3   0.000493   0.000034     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
    3              0.000027     return join(parts)

FUNCTION  22()
Called 3 times
Total time:   0.012571
 Self time:   0.000122

count  total (s)   self (s)
    3   0.000211   0.000023     call self.syncExec()
    3              0.000013     if !has_key(self, '_available')
    1   0.012304   0.000043         let self._available = self._isAvailableFunc()
    1              0.000003     endif
    3              0.000010     return self._available

FUNCTION  24()
Called 3 times
Total time:   0.000138
 Self time:   0.000068

count  total (s)   self (s)
    3   0.000122   0.000052     return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)

FUNCTION  27()
Called 3 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    3              0.000023     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  28()
Called 15 times
Total time:   0.002558
 Self time:   0.000976

count  total (s)   self (s)
   15              0.000064     let ret = []
   15   0.000629   0.000221     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
   15   0.001100   0.000321     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
   15   0.000590   0.000195     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
   15              0.000035     return ret

FUNCTION  153()
Called 16 times
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
   16              0.000199   call add(self._sections, [a:group, a:contents])

FUNCTION  syntastic#util#shescape()
Called 13 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
   13              0.000287     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  airline#builder#new()
Called 2 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    2              0.000027   let builder = copy(s:prototype)
    2              0.000013   let builder._context = a:context
    2              0.000010   let builder._sections = []
                            
    2              0.000042   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    2              0.000008   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   91   0.285894   0.021304  airline#check_mode()
   13   0.261878   0.092410  airline#highlighter#highlight()
    3   0.222616   0.000174  <SNR>25_BufWritePostHook()
    3   0.222343   0.001160  <SNR>25_UpdateErrors()
    3   0.184037   0.002178  <SNR>25_CacheErrors()
    4   0.128298   0.001203  syntastic#util#system()
    3   0.125766   0.000129  17()
    3   0.125127   0.000638  16()
    3   0.123535   0.000312  SyntaxCheckers_python_python_GetLocList()
    3   0.119859   0.002711  SyntasticMake()
  161   0.113984   0.013679  <SNR>61_exec_separator()
  346   0.089981   0.025584  airline#highlighter#get_highlight()
  322   0.089167   0.005142  airline#themes#get_highlight()
  936   0.077855             airline#highlighter#exec()
  692   0.052911             <SNR>61_get_syn()
   92   0.040469             <SNR>43_Highlight_Matching_Pair()
    3   0.037644   0.000299  82()
    3   0.037092   0.029321  90()
    3   0.035633   0.002838  77()
    2   0.032369   0.000131  <SNR>27_on_window_changed()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   13   0.261878   0.092410  airline#highlighter#highlight()
  936              0.077855  airline#highlighter#exec()
  692              0.052911  <SNR>61_get_syn()
   92              0.040469  <SNR>43_Highlight_Matching_Pair()
    3   0.037092   0.029321  90()
    2              0.029179  syntastic#util#redraw()
  346   0.089981   0.025584  airline#highlighter#get_highlight()
    3   0.022569   0.021884  8()
   91   0.285894   0.021304  airline#check_mode()
   91   0.016873   0.016690  49()
   91   0.017203   0.016644  airline#extensions#whitespace#check()
  161   0.113984   0.013679  <SNR>61_exec_separator()
  637              0.012463  airline#util#wrap()
  364              0.012257  airline#util#append()
  346              0.011486  <SNR>61_get_array()
  322   0.089167   0.005142  airline#themes#get_highlight()
   91   0.010947   0.004723  airline#extensions#branch#get_head()
   53              0.004329  <SNR>59_update()
   91              0.003527  airline#parts#ffenc()
    2   0.024902   0.003434  155()

